[["index.html", "STAT 107 Outline of Class Notes Welcome", " STAT 107 Outline of Class Notes Rebecca Kurtz-Garcia 2022-07-27 Welcome Welcome to STAT 107! This document will contain and outline of the course notes throughout the quarter. Please see the course website for an approximate schedule. In each of the chapters there will be a list of links, resources, and videos for learning more about an individual topic. This document will be updated constantly, be sure to check here for periodic updates. In addition, this document does not serve as a substitute for in class instruction, but more as a guide for the general content we discuss. Students are still expected to attend every lecture. "],["introduction-to-r.html", "Chapter 1 Introduction to R 1.1 Download and Install R and Rstudio 1.2 The RStudio Interface 1.3 Comments 1.4 Operators 1.5 Naming Conventions Additional Resources", " Chapter 1 Introduction to R In this chapter we introduce R and RStudio, which you’ll be using throughout this course to learn how to analyze real data and come to informed conclusions. To straighten out which is which: R is the name of the programming language itself, and RStudio is a convenient interface for using R. As the course progresses, you are encouraged to explore beyond what we discuss; a willingness to experiment will make you a much better scientist and researcher. Before we get to that stage, however, you need to build some competence in R. We begin with some of the fundamental building blocks of R and Rstudio: the interface, data types, variables, importing data, and plotting data. R is widely used by the scientific community as a no-cost alternative to expensive commercial software packages like SPSS and MATLAB. It is both a statistical software analysis system and a programming environment for developing scientific applications. Scientists routinely make available for free R programs they have developed that might be of use to others. Hundreds of packages can be downloaded for all types of scientific computing applications. This chapter was written by the help of Dr. Robert Desharnais (2020). 1.1 Download and Install R and Rstudio To get started, you need to download both the R and Rstudio software. Both are available for free and there are versions for Linux, Mac OS X, and Windows. It is suggested that you download R first and then Rstudio. R can be used without RStudio, but RStudio provides a convenient user interface and programming environment for R. The details for downloading and installing these software packages varies depending on your computer and operating system. You may need permission to install the software on your computer. The links below provide access to a mirror archive at UCLA for downloading R and the developer’s site for downloading RStudio. To download R, go to the url https://ftp.osuosl.org/pub/cran. Choose the binary distribution appropriate for your computer. Windows users will want to click on the link to “Download R for Windows” and choose “install R for the first time,” then “Download R 3.5.2 for Windows.” Mac OS users will want to click “Download R for (Mac) OS X.” Download the install package for version R-3.5.2 If you are using Mac OS X 10.9-10.10, install version R-3.3.3. If you are using OS X 10.6-10.8, install version R-3.2.1. Linux users will want to click on the link to “Download R for Linux.” You will need to choose the version of Linux that corresponds to your installation. Versions are available for Debian, RedHat, SUSE, and Ubuntu. For RStudio, use the url https://www.rstudio.com/products/rstudio/download/. Choose the binary distribution appropriate for your computer. Installers are provided for a variety of platforms. For additional help please see this video: Getting Started 1 | How to Download and Install RStudio 1.2 The RStudio Interface We will begin by looking at the RStudio software interface. The RStudio program is referred to the window, and each section in the interface is a pane. Launch RStudio. You will see a window that looks like the figure above. The four panes of the window are described as follows: The pane in the bottom left is the R Command Console, this is where you type R commands for immediate execution. The pane in the upper left portion of the window is an area for editing R source code for scripts and functions and for viewing R data frame objects. New tabs will be added as new R code files and data objects are opened. The pane in the upper right portion of the window is an area for browsing the variables in the R workspace environment and the R command line history. The pane in the lower right portion of the window has several tabs. The Files tab is an area for browsing the files in the current working directory. The Plot tab is for viewing graphics produced using R commands. The Packages tab lists the R packages available. Other packages can be loaded. The Help tab provides access to the R documentation. The Viewer tab is for viewing local web content in the temporary session directory (not files on the web). Bottom Left Pane Let’s begin with the Console. This is where you type R commands for immediate execution. Click in the Command Console, “&gt;” symbol is the system prompt. You should see a blinking cursor that tells you the console is the current focus of keyboard input. Type: 1+2 ## [1] 3 The result tells you that the line begins with the first (and only) element of the result which is the number 3. You can also execute R’s built-in functions (or functions you add). Type the following command. exp(pi) ## [1] 23.14069 In R, “pi” is a special constant to represent the number and “exp” is the exponential function. The result tells you that the first (and only) element of the result is the number \\(e^{\\pi}=\\) 23.14069. Bottom Right Pane Now let’s look at the Files tab of the notebook at the lower right of the window. Every R session has a working directory where R looks for and saves files. It is a good practice to create a different directory for every project and make that directory the working directory. For example, let’s make a new directory called MyDirectory. (You can chose another name if you wish). Click on the Files tab of the notebook. You should see a listing of files in your default working directory. Click on the small button with an ellipsis image on the right side of the file path above the directory listing. Navigate to the folder where you want to create the new directory and click the OK button. Click on the New Folder button just below the Files tab (see right). Type MyDirectory in the panel that opens click on the folder in the Notebook. Click the More button to the right of the New Folder button and select the menu option Set as Working Directory. This new folder is now the working directory for the current R session. This menu option is a short cut for a command that was automatically entered into the R console. Top Right Pane Next we will look at the R environment, also called the R workspace. This is where you can see the names and other information on the variables that were created during your R session and are available for use in other commands. In the R console type: a &lt;- 29.325 b &lt;- log(a) c &lt;- a/b Look at the Environment pane. The variables a, b, and c are now part of your R work space. You can reuse those variables as part of other commands. In the R console type: v &lt;- c(a, b, c) v ## [1] 29.325000 3.378440 8.680041 The variable v is a vector created using the concatenate function c(). (The concatenate should not be confused with the variable c that was created earlier. Functions are always followed by parentheses that contain the function arguments). This function combines its arguments into a vector or list. Look at the Environment panel. The text num [1:3] tells us that the variable v is a vector with elements v[1], v[2], and v[3]. Top Left Pane Now let’s look at the R viewer notebook. This panel can be used to data which are data frame objects or matrix objects in R. We will begin by taking advantage of a data frame object that was built into R for demonstration purposes. We will copy it into a data frame object. In the R console, type: df &lt;- mtcars Let’s view the data. On the right side of the entry for the df object is a button we can use to view the entries of the data frame. Click on the View Button. If your look in the notebook area in the upper left portion of the window, you can see a spreadsheet-like view of the data. This is for viewing only; you cannot edit the data. Use the scroll bars to view the data entries. You can also list the data in the console by typing the name of the data fame object: df ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 The columns are labeled with the names of the variables and the rows are labeled with the names of each car. Each row represents the data values for one car; that is, each row is one observation. 1.3 Comments Often times we will want to add a comment to our script document so we can remember special aspects later, and make the code easier to read and modify in the future. To add a comment start the comment with a # symbol. This will make the remaining characters in a line a comment and R will not try to compile these lines. Go to the script document and type the following. Highlight what you have typed and press “Run”. # This is a comment 2+ 2 ## [1] 4 2 + 3 # Comments can also start in the middle of a line. ## [1] 5 1.4 Operators An operator is a symbol that tells the compiler to preform a specific task. There are several types of operators, some preform mathematical tasks, logical checks, and create new objects. We will review a few of the basic operators here. We will continue to discuss and introduce operators throughout this document. Arithmetic Operators R was designed for statistical applications and as a necessity it needs to preform mathematical operations efficiently and effectively. The first operators we discuss are a few of the basic arithmetic operations. These are operations similar to that of a calculator. # Addition 2 + 3 ## [1] 5 # Subtraction 2 - 3 ## [1] -1 # Multiplication 2*3 ## [1] 6 # Division 2/3 ## [1] 0.6666667 # Exponent 2^3 ## [1] 8 Relational Operators Relational operators are used to compare two values. When using a relational operation R will return either TRUE or FALSE. # Less than 2 &lt; 3 ## [1] TRUE # Greater than 2 &gt; 3 ## [1] FALSE # Less than or equal to 2 &lt;= 3 ## [1] TRUE # Greater than or equal to 2&gt;= 3 ## [1] FALSE # Not equal to 2 != 3 ## [1] TRUE # Equal to 2 == 3 ## [1] FALSE We can use all the same operators above if our object contains more than one element. This will preform the above comparisons element by element. v ## [1] 29.325000 3.378440 8.680041 v &gt; 10 ## [1] TRUE FALSE FALSE If we have two vectors of an unequal length then the checks will be preformed element-by-element but the values in the shorter vector will be recycled, or repeated. w &lt;- c(10, 1) v &gt; w ## Warning in v &gt; w: longer object length is not a multiple of shorter object ## length ## [1] TRUE TRUE FALSE R evaluated the first and third element of v and compared it to the first element of w, and the second element of v to the second element of w. In this case, R returned a warning alerting you that it recycled elements. However, R will not always give a warning. Logical operators Logical operators are similar to relational operators. They are used to check “AND” and “OR” events. We have the &amp; symbol which returns TRUE only if BOTH conditions are true. We also have the | symbol which returns TRUE if EITHER condition is true. # Check if both operations are true. (2 &lt; 3) &amp; (5 &lt; 4) ## [1] FALSE # Check if either operation is true. (2 &lt; 3) | (5 &lt; 4) ## [1] TRUE We can also negate a TRUE or FALSE value using the ! symbol. # Negate an operation !(2&lt;3) ## [1] FALSE Like relational operators from before, if we have more than one element the logical operations will be implemented element-by-element. # AND event, compared element-by-element (v &gt; 10) &amp; (4 &lt; 5) ## [1] TRUE FALSE FALSE # OR event, compared elmeent-by-elment (v &gt; 10) | (4 &lt; 5) ## [1] TRUE TRUE TRUE We also have the symbols &amp;&amp; and || which will ensure that only the first element in an object will be compared. # AND event, only check the first element (v &gt; 10) &amp;&amp; (4 &lt; 5) ## [1] TRUE # OR event, only check the first element (v &gt; 10) || (4 &lt; 5) ## [1] TRUE Assignment Operators Assignment operators are used to assign values to a new object. There are many types of assignment operators, and they operate slightly differently. The two most common assignment operators are = and &lt;-. With these operators the value to the left of the operator is the name of the new object and the value on the right is what the object is now equal to. x = 5 x ## [1] 5 x &lt;- 5 x ## [1] 5 The majority of the time we can use these two assignment operators above interchangeably, there are some exceptions though. There are several other assignment operators which are uncommon and should only be used by advanced users, -&gt;, &lt;&lt;-, and -&gt;&gt;. When we create new objects it is called binding. Consider the code below. v &lt;- c(6, 2, 5) In this line of code the object c(6, 2 ,5) is binded to the name v. That is, v acts as a reference (or a placeholder) for the object c(6, 2, 5). Everywhere we see the object v we should mentally replace it with this vector. 1.5 Naming Conventions R has rules when it comes to naming objects. An object may start with a letter or a ., and the remaining characters may consist of letters, digits, . or _. There are also special types of objects that have already established names in R. For example, NULL, TRUE, FALSE, if, and function should not be used as a new object name. To see a list of these reserved object names type ?Reserved in to your console. Additional Resources Chapter 1 of “CRAN Intro-to-R Manual” Videos: Getting Started 1 | How to Download and Install RStudio Getting Started 2 | Rstudio Introduction cont’d, More Tabs Explained References "],["atomic-vectors.html", "Chapter 2 Atomic Vectors 2.1 Examples 2.2 Basic Features Summary Additional Resources", " Chapter 2 Atomic Vectors At its core, R is an objected-oriented computational and programming environment. Everything in R is an object with different properties. In this chapter we will go over vectors, these are the core fundamental objects used in R. A vector in R is a 1-dimensional object. That is, it contains a sequence of elements in a particular order. For example, v &lt;- c(2, 6, 5) is a vector with three elements. The first element is a 2, the second is a 6, and third is a 5. An object with just a single element, w &lt;- 3 is just a vector with only one value. R can represent different types of data. The types include double, integer, complex, logical, character, and raw. These are the basic fundamental objects we can use in R and are referred to as the atomic values. For our class we will not need the complex type which stores complex numbers, and in practice raw is rarely used. We will concentrate on the remaining four types. Unlike other object-oriented languages we do not need to specify what type of object we are creating when we create it. Instead, R guesses the type of object you are creating. To create an atomic vector we use the concatenate function c(), where each element of the vector is separated by a comma. This function will always create an atomic vector. double: A vector of real numbers (numbers which may contain decimal values). We can create these vectors using decimal (12.34) or scientific form (.1234e2). When using numbers this is the default type used. integer: A vector of integers (whole numbers). We can create these vectors using a integer followed by a letter L, i.e. 5L. logical: A vector containing only TRUE or FALSE values. We can create the these vectors using TRUE and FALSE explicitly, or by doing T or F. character: A vector containing strings. A string is a sequence of characters made using double quotes or single quotes, i.e. “Hello” and ‘Goodbye’. An atomic vector only contains elements of the same type. If the function c() is given a mix of elements then it will convert these elements to be all of the same type according to a hierarchy of rules. The only exception to this is for NA values. The object NA is used to indicate missingness, or the lack of a value. The value NA can occur anywhere for all types of vectors. To check the object type we can use the typeof() function. Vectors are among the most common types that are used. All of the different types of vectors we will learn about have special properties and a multitude of features that we can use. We discuss some of their key properties here, but will continue exploring and learning about their features, and introducing more object types throughout the course. 2.1 Examples Double Vectors containing double vectors are perhaps the most common. These objects are comparable to doubles in the programming language C. Both the variables a and b are double vectors. When you type a number R will default to creating a double vector. a &lt;- 17.45 typeof(a) ## [1] &quot;double&quot; b &lt;- 5 typeof(b) ## [1] &quot;double&quot; c &lt;- c(1, 12.05, 123e-4) typeof(c) ## [1] &quot;double&quot; Integer We can also create integer vectors which are specifically made to store integer values. We can do this by following a whole number with the letter L. a &lt;- 5L typeof(a) ## [1] &quot;integer&quot; b &lt;-c(1L, 2L, 3L) typeof(b) ## [1] &quot;integer&quot; Notice that when we define b&lt;-5 and b &lt;- 5L and type b into our console it appears the same. That is, to the user the two definitions look the same. However, in R integers and doubles are stored in the computer differently and have different features. For the most part, the difference between integers and doubles is negligable; however, sometimes it can produce strange errors. Logical Logical values are either TRUE or FALSE and are created by using logical or relational operators. In other words, they are created by using statements that compare variables. There are several ways to do logical statements as we saw in Section 1.4. n &lt;- (10&lt;11) typeof(n) ## [1] &quot;logical&quot; m &lt;- c(10&lt;11, 4&gt;5, 3!=1) typeof(m) ## [1] &quot;logical&quot; We can also assign a value as TRUE or FALSE manually by setting it equal to TRUE or FALSE, or by using T or F. c &lt;- T typeof(c) ## [1] &quot;logical&quot; # Can mix up TRUE/FALSE and T/F d &lt;-c(T, F, TRUE) typeof(d) ## [1] &quot;logical&quot; Character Character values are text. They are often used as data values and labels. # Double quotes first &lt;- &quot;George&quot; typeof(first) ## [1] &quot;character&quot; # Single quotes last &lt;- &#39;Washington&#39; typeof(last) ## [1] &quot;character&quot; full &lt;- c(first, last) typeof(full) ## [1] &quot;character&quot; 2.2 Basic Features R is a vectorized language, meaning most of the procedures, functions, and operations have been optimized to work with vectors. It is typically advantageous to utilize this feature. 2.2.1 Length We have already learned that we can create vectors using the function c(), but this can also be used to make a vector larger. To see how many elements are in a vector we use the length() function v1 = c(1, 5, 6) typeof(v1) ## [1] &quot;double&quot; length(v1) ## [1] 3 v2 = c(-0.41, -1.20, pi) typeof(v2) ## [1] &quot;double&quot; length(v2) ## [1] 3 v = c(v1, v2) typeof(v) ## [1] &quot;double&quot; length(v) ## [1] 6 v ## [1] 1.000000 5.000000 6.000000 -0.410000 -1.200000 3.141593 2.2.2 Vectorized Operations and Recylcing Vectors can be used in arithmetic computations. If the two vectors are of the same length, the computations are performed element-by-element. v1 + v2 ## [1] 0.590000 3.800000 9.141593 v1 * v2 ## [1] -0.41000 -6.00000 18.84956 Single numbers (scalars) will operate on all the vector elements in an expression. 5*v1 ## [1] 5 25 30 v1/3 ## [1] 0.3333333 1.6666667 2.0000000 If you have vectors of different sizes R will recycle values in the smaller vector in order to complete the operation. Sometimes R will give you a warning for this, but often it does not. a &lt;- c(1, 2, 30) b &lt;- c(10, 20) a + b ## Warning in a + b: longer object length is not a multiple of shorter object ## length ## [1] 11 22 40 a &lt; b ## Warning in a &lt; b: longer object length is not a multiple of shorter object ## length ## [1] TRUE TRUE FALSE 2.2.3 Coercion As mentioned above, all elements within a vector must be of the same type. If you attempt to create a vector where some elements are of a different type than the another then R will convert all the elements to be of one type. For example, observe what happens when we try to create a vector with logical and double values. d &lt;- c(TRUE, F, TRUE, 5, 6, 10) d ## [1] 1 0 1 5 6 10 typeof(d) ## [1] &quot;double&quot; In the above example the values for TRUE where converted into 1 and FALSE was converted into a 0. R did the above coercion automatically, but sometimes you will want to convert a vector type explicitly. To do this we use the as.*() functions, where * is replaced by “double”, “integer”, “character”, or “logical”. # Convert to a character vector char_d &lt;- as.character(d) char_d ## [1] &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;5&quot; &quot;6&quot; &quot;10&quot; typeof(char_d) ## [1] &quot;character&quot; # Convert to an integer vector e &lt;- c(1, 2, 3) typeof(e) ## [1] &quot;double&quot; e ## [1] 1 2 3 e &lt;- as.integer(e) typeof(e) ## [1] &quot;integer&quot; e ## [1] 1 2 3 It is not always possible to convert vector types. Sometimes an element of a vector will fail to convert. If this happens a warning may be given, and the value is often replaced by NA. 2.2.4 Testing We can also test what type of object that we have using the is.*() function, where * is replaced by “logical”, “double”, “integer”, or “character”. These function will return TRUE is * matches the typeof() output, and will return FALSE if otherwise. # Create a double vector a &lt;- c(1, 2, 30) typeof(a) ## [1] &quot;double&quot; is.integer(a) # Returns FALSE ## [1] FALSE is.double(a) # Returns TRUE ## [1] TRUE 2.2.5 Names You can name elements of a vector as well. This will produce a named vector. Instead of referring to an elements location in a vector by its order number, you can refer to the name. We can create names for a vector using three different methods. When creating it. By assigning a character vector to names() Inline with setNames() To create a named vector using the first technique we use the = symbol where the name is on the left of the equal sign, and the element binded to that name is on the right. All of the atomic vectors can be defined so their elements are named. # Using Technique 1 for creating a named vector. named1 &lt;- c(first = &quot;Abraham&quot;, last = &quot;Lincoln&quot;) named1 ## first last ## &quot;Abraham&quot; &quot;Lincoln&quot; To create a named vector using the second technique we use the names() function. This is the most common technique. # Using Technique 2 for creating a named vector named2 &lt;- c(1, 2, 3) names(named2) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;) named2 ## first second third ## 1 2 3 To create a named vector using the third technique we use the setNames() function. This is the least common technique and is hardly used. # Using Technique 3 for creating a named vector named3 &lt;- c(T, F, T) named3 &lt;- setNames(named3, c(&quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;)) named3 ## e1 e2 e3 ## TRUE FALSE TRUE To see the list of names for a vector at any point use the names() function. When this function is on the right side of an assignment operator this will produce the names of each element of the vector. # To see the names of a vector and not the elements names(named3) ## [1] &quot;e1&quot; &quot;e2&quot; &quot;e3&quot; If you want to remove the names of a vector you can use two techniques. The first technique is to redefined the vector you with to remove the names of with the unname() function. The second technique uses the names() function and sets the names to be equal to NULL. # Remove names using unname() named2 &lt;- unname(named2) named2 ## [1] 1 2 3 # Remove names using names() and NULL names(named3) &lt;- NULL named3 ## [1] TRUE FALSE TRUE 2.2.6 typeof() and class() The typeof() function returns the storage mode of an object, and the types of values this function will return is limited. The six atomic types of vectors each are based on the six fundamental ways R stores data. Thus when we make a standard vector, we can use the typeof() function to see which type of vector we have. There is also a function called class() which is more common to use, and what we will focus on for the rest of the course. The class() function returns very similar output as typeof(), but it can also return more specific types or forms of objects. For example, perhaps you have a vector with special properties or set up. Then you can assign this specific type of vector with a certain class that reflects these properties, and R will know to differentiate how it handles this object based on its class, instead of its storage mode (returned by typeof()). The major difference between the output of typeof() and class() for atomic vectors is that when we have an integer or double vector the class function returns “numeric” for both. v_int &lt;- c(1L, 2L, 3L) class(v_int) ## [1] &quot;integer&quot; v_dbl &lt;- c(1, 2, 3) class(v_dbl) ## [1] &quot;numeric&quot; 2.2.7 Accessing Elements of a Vector Individual elements of a vector can be obtained using an index in square brackets. An index is the location of an element in a vector. For example, the vector v_dbl&lt;- c(10, 11, 12) has three elements. The first elements index is 1, the second elements index is 2, and so on. A negative index removes that element from the vector. The v_dbl[-1] is the vector v_dbl with the first element removed. The concatenate function can be used to obtain two or more elements of a vector in any desired order. Here v_dbl[c(3,2)] returns the third and second elements of the vector v_dbl. v_dbl &lt;- c(10, 11, 12) # Only get the third element v_dbl[3] ## [1] 12 # Get all elements except the first one v_dbl[-1] ## [1] 11 12 # Get the third and second element v_dbl[c(3,2)] ## [1] 12 11 Summary There are 6 types atomic vectors, but four we will primarily focus on: character, logical, integer, and double. The c() function is used to create atomic vectors, and it combines vectors together. All elements of a vector are of the same type. typeof() and class() functions return what type of vector you have. The length() function tells us how many elements are in a vector. The names() and setNames() function can be used to create a named vector. as.*() can be used to convert the type of vector. is.*() can be used to test what type of vector you have. We can access an element of a atomic vector by using v[num], where v is the vector, and num is the index (or location) of the element we are trying to access. Summary of the vectors that we will be learning about. Additional Resources Chapters 2, 3, 4.1, 4.3, 5.1-5.3, 6 of CRAN Intro-to-R Manual Videos: Variables 1 | Types and Assignments Variables 2 | Nameing Conventions and Best Practices Vectors 1 | Introduction Chapters 4.6-4.8 of Chapter 13 of “R for Programming in Data Science” Chapter 4 of Adanvced R "],["factors-and-lists.html", "Chapter 3 Factors and Lists 3.1 Factors 3.2 Factors - Basic Features 3.3 Lists 3.4 List - Basic Features Summary Additional Resources", " Chapter 3 Factors and Lists Factor objects and lists are vectors with special properties. Factors and lists are vectors because they a 1-dimensional sequence of elements. Factors are primarily used for categorical data, and are technically a special form of an integer type vector. However, we will simply refer to a factor vector a as a factor object. Lists are vectors where type of each element can differ. In this chapter we introduce some of the unique properties of factors and lists. 3.1 Factors In real-world problems, you often encounter data that can be classified in categories. For example, suppose a survey was conducted of a group of seven individuals, who were asked to identify their hair color. hair &lt;- c(&quot;Blonde&quot;, &quot;Black&quot;, &quot;Black&quot;, &quot;Red&quot;, &quot;Blonde&quot;, &quot;Brown&quot;, &quot;Black&quot;) Here, the hair color is an example of categorical data. For the hair color variable we will typically want to store it as a factor, as opposed to a character vector. The different values that the factor can take are called levels. In R, you can create a factor with the factor(), or the as.factor() functions. f &lt;- factor(hair) f ## [1] Blonde Black Black Red Blonde Brown Black ## Levels: Black Blonde Brown Red 3.1.1 Levels Levels are one of the special properties of a factor object. Notice that when you print the factor, R displays the distinct levels below the factor. R keeps track of all the possible values in a vector, and each value is called a level of the associated factor. The levels() function shows all the levels from a factor. levels(f) ## [1] &quot;Black&quot; &quot;Blonde&quot; &quot;Brown&quot; &quot;Red&quot; If your vector contains only a subset of all the possible levels, then R will have an incomplete picture of the possible levels. Consider the following example of a vector consisting of directions. Notice that “South” is noticeably missing. directions &lt;- c(&quot;North&quot;, &quot;West&quot;, &quot;North&quot;, &quot;East&quot;, &quot;North&quot;, &quot;West&quot;, &quot;East&quot;) f &lt;- factor(directions) f ## [1] North West North East North West East ## Levels: East North West Notice that the levels of your new factor do not contain the value “South”. R thinks that North, West, and East are the only possible levels. However, in practice, it makes sense to have all the possible directions as levels of your factor. To add all the possible levels explicitly, you specify the levels argument of the function factor(). # Make sure all possible categories are listed using the levels argument f &lt;- factor(directions, levels = c(&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;)) f ## [1] North West North East North West East ## Levels: North East South West R lets you assign abbreviated names for the levels. You can do this by specifying the labels argument of factor(). f &lt;- factor(directions, levels = c(&quot;North&quot;, &quot;East&quot;, &quot;South&quot;, &quot;West&quot;), labels = c(&quot;N&quot;, &quot;E&quot;, &quot;S&quot;, &quot;W&quot;)) f ## [1] N W N E N W E ## Levels: N E S W 3.1.2 Ordered Factor Sometimes data has some kind of natural order between elements. For example, sports analysts use a three-point scale to determine how well a sports team is competing: loss &lt; tie &lt; win. In market research, it’s very common to use a five point scale to measure perceptions: strongly disagree &lt; disagree &lt; neutral &lt; agree &lt; strongly agree. Such kind of data that is possible to place in order or scale is known as ordinal data. We can store ordinal data as an ordered factor. To create an ordered factor, use the factor() function with the argument ordered=TRUE. record &lt;- c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;win&quot;) f &lt;- factor(record, ordered = TRUE) f ## [1] win tie loss tie loss win win ## Levels: loss &lt; tie &lt; win You can manually change which levels are lower and higher based on the order that the levels are listed. record &lt;- c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;tie&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;win&quot;) f &lt;- factor(record, ordered = TRUE, levels = c(&quot;win&quot;, &quot;tie&quot;, &quot;loss&quot;)) f ## [1] win tie loss tie loss win win ## Levels: win &lt; tie &lt; loss If you have no observations in one of the levels, you can drop it using the droplevels() function. record = c(&quot;win&quot;, &quot;loss&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;loss&quot;, &quot;win&quot;) f = factor(record, levels = c(&quot;loss&quot;, &quot;tie&quot;, &quot;win&quot;)) droplevels(f) ## [1] win loss loss win loss win ## Levels: loss win 3.2 Factors - Basic Features 3.2.1 Length Factor objects have a lot of the same features as atomic vectors. In general, most of the features and functions we had for atomic vectors work with factors. For example, we still use the length() function to see how many elements are in a factor. length(f) ## [1] 6 3.2.2 Coercion Coercion also works similarly. We can use as.factor() to create a factor object from a pre-existing vector. As we have seen in the previous examples, the factor() function also works. record &lt;- c(&quot;win&quot;, &quot;loss&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;loss&quot;, &quot;win&quot;) f &lt;- as.factor(record) f ## [1] win loss loss win loss win ## Levels: loss win To convert a factor object to a non-factor object we still use the as.*() function. In general, it is usually easiest to convert character vectors to factor vectors, and vice versa. When we convert a factor to an integer or double vector the different levels of the factor are converted to integers in order for each level. That is, the first level listed is converted to a 1, the second level listed is converted to a 2, and so on. # Convert to a character vector as.character(f) ## [1] &quot;win&quot; &quot;loss&quot; &quot;loss&quot; &quot;win&quot; &quot;loss&quot; &quot;win&quot; # Convert to an integer vector as.integer(f) ## [1] 2 1 1 2 1 2 3.2.3 Testing/Class We can also test if we have factor or an ordered factor using is.*() as we did before. record &lt;- c(&quot;win&quot;, &quot;loss&quot;, &quot;loss&quot;, &quot;win&quot;, &quot;loss&quot;, &quot;win&quot;) f &lt;- factor(record, ordered = T) # Test if the character vector is a factor is.factor(record) ## [1] FALSE # Test if we have a factor (includes both ordered and not ordered factors) is.factor(f) ## [1] TRUE # Test if we have an ordered factor (only includes ordered factors) is.ordered(f) ## [1] TRUE With all types of objects we can use the class() function. As mentioned in the previous section, this function returns the name of the type of object that you have, unlike typeof() which returns the storage mode. The output of class() returns name of a object with particular properties. For instance, a factor object. A factor object is stored like an integer vector but it has “levels” which can be utilized in special ways. # Returns storage mode (not recommended) typeof(f) ## [1] &quot;integer&quot; # Returns class, which is the name of a collection of objects with similar properties # (Recommended) class(f) ## [1] &quot;ordered&quot; &quot;factor&quot; 3.2.4 Names Like standard vectors, we can name the elements in a factor using the same three techniques discussed in 2.2.5. # Using Technique 1 for creating a named vector. named1 &lt;- c(sally = &quot;win&quot;, tom = &quot;win&quot;, ed = &quot;lost&quot;, jane = &quot;tie&quot;) named1 &lt;- factor(named1) named1 ## sally tom ed jane ## win win lost tie ## Levels: lost tie win 3.2.5 Accessing Elements We can also access elements of a factor object using the same standard techniques described for accessing elements in a vector 2.2.7. # Obtain the first element named1[1] ## sally ## win ## Levels: lost tie win # Obtain the forth and second elements named1[c(4, 2)] ## jane tom ## tie win ## Levels: lost tie win 3.2.6 Frequency Tables The summary() function will give you a quick overview of the contents of a factor. hair &lt;- c(&quot;Blonde&quot;, &quot;Black&quot;, &quot;Black&quot;, &quot;Red&quot;, &quot;Blonde&quot;, &quot;Brown&quot;, &quot;Black&quot;) hair &lt;- factor(hair) summary(hair) ## Black Blonde Brown Red ## 3 2 1 1 The function table() tabulates observations. table(hair) ## hair ## Black Blonde Brown Red ## 3 2 1 1 We can also use the table() and summary() functions on atomic vectors, and they will operate in a similar way. However, these functions are particularly utilized for factor objects. The table() function can also tabulate two-way frequency tables. hair &lt;- c(&quot;Blonde&quot;, &quot;Black&quot;, &quot;Black&quot;, &quot;Red&quot;, &quot;Blonde&quot;, &quot;Brown&quot;, &quot;Black&quot;) own_pets &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE) hair &lt;- factor(hair) own_pets &lt;- factor(own_pets) # Two way table table(hair, own_pets) ## own_pets ## hair FALSE TRUE ## Black 2 1 ## Blonde 1 1 ## Brown 1 0 ## Red 0 1 3.3 Lists A list is an array of objects. Unlike other types of vectors, the elements in a list can belong to different classes. Lists are useful for packaging together a set of related objects. We can create a list of objects in our environment by using the list() function. # A list of mixed datatypes lst &lt;- list(1L, c(&quot;abc&quot;, &quot;ABC&quot;), 1.23, TRUE) lst ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;abc&quot; &quot;ABC&quot; ## ## [[3]] ## [1] 1.23 ## ## [[4]] ## [1] TRUE Looking at the output above we can see that this output is structured differently than a standard vector. The location of each element of a list is denoted by [[]] instead of []. The best way to understand the contents of a list is to use the structure function str(). It provides a compact display of the internal structure of a list. lst &lt;- list(1, c(&quot;abc&quot;, &quot;ABC&quot;), 1.23, TRUE) str(lst) ## List of 4 ## $ : num 1 ## $ : chr [1:2] &quot;abc&quot; &quot;ABC&quot; ## $ : num 1.23 ## $ : logi TRUE Above we see that we have a list with 4 elements. The first element is of class “numeric” and contains a single number, 1. The second element is of “character” and contains two elements, which is indicated by [1:2]. The third and fourth elements are of class “numeric” and “logical”, and each contain a single element. To see the class of each indivdiual element of a list we can use the following command. sapply(lst, class) ## [1] &quot;numeric&quot; &quot;character&quot; &quot;numeric&quot; &quot;logical&quot; 3.3.1 Nested Lists A list can contain sublists, which in turn can contain sublists themselves, and so on. This is known as nested list or recursive vectors. lst &lt;- list(1, 3, c(&quot;abc&quot;, &quot;ABC&quot;), list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), TRUE) str(lst) ## List of 5 ## $ : num 1 ## $ : num 3 ## $ : chr [1:2] &quot;abc&quot; &quot;ABC&quot; ## $ :List of 3 ## ..$ : chr &quot;a&quot; ## ..$ : chr &quot;b&quot; ## ..$ : chr &quot;c&quot; ## $ : logi TRUE 3.4 List - Basic Features 3.4.1 Length Despite looking different and being stored differently than atomic vectors and factors, lists have many of the same properties and features. For example, we still can use the length() function to determine how many elements are in a list. lst &lt;- list(1, 3, c(&quot;abc&quot;, &quot;ABC&quot;), list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), TRUE) length(lst) ## [1] 5 In the example of both there are 5 items in a list. The first two elements are double vectors of length 1, the third element is a character vector of length two, the fourth element is a list of length three, and the fifth element is a logical vector of length 1. Add elements to a list using c() as we did before with atomic vectors. lst_char &lt;- list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) lst_num &lt;- list(100, 99, 0) lst &lt;- c(lst_num, lst_char) str(lst) ## List of 6 ## $ : num 100 ## $ : num 99 ## $ : num 0 ## $ : chr &quot;a&quot; ## $ : chr &quot;b&quot; ## $ : chr &quot;c&quot; 3.4.2 Coercion We can convert atomic vectors and factors into lists by simply using the as.list() function. The as.list() function lets each element in a vector correspond to each element in the list. So the first element of the vector becomes the first element of the list, the second element of the vector becomes the second element of the list, and so on. We could also use the list() function but this will convert a vector into a list in a different way. num_vec &lt;- c(1, 2, 3) num_lst &lt;- as.list(num_vec) str(num_lst) ## List of 3 ## $ : num 1 ## $ : num 2 ## $ : num 3 We can convert lists to one of the other types of vectors using the as.*() function with the desired vector type as we did earlier. However, if we do not have a desired type in mind we can also use the unlist() function. The unlist() function takes all atomic objects in a list and creates an atomic vector. In this case R will “guess” which type of atomic vector you would like. unlist(num_lst) ## [1] 1 2 3 3.4.3 Testing/Class We can determine if an object is a list or not by using is.list() or the class() functions. is.list(num_lst) ## [1] TRUE class(num_lst) ## [1] &quot;list&quot; 3.4.4 Names Lists can also be named, and often are. It is very common to created named lists because lists can have a mix of different types objects. We can create a named list using all the same techniques that we used for creating named vectors (2.2.5) . Notice, we do not have to create a name for every element in a list. Below we see the first two elements are named, and the last is not. lst &lt;- list(first = &quot;Abraham&quot;, last = &quot;Lincoln&quot;, 1860) lst ## $first ## [1] &quot;Abraham&quot; ## ## $last ## [1] &quot;Lincoln&quot; ## ## [[3]] ## [1] 1860 3.4.5 Accessing Elements Accessing elements in a list is a little different than accessing elements in a vector. As you may have already noticed, when a list is outputted into our console the elements in the list are denoted by their index number inside of double brackets, i.e. [[2]]. To access this individual element in a list we use double brackets. This isolates that individual element, and the class of this element is no longer a list but the class of the original element. lst[[1]] ## [1] &quot;Abraham&quot; class(lst[[1]]) ## [1] &quot;character&quot; We can still use single brackets to access elements in a list, but this method of indexing simply subsets the list. That is, it still returns us a list, just a smaller one based on the indices called. lst[1] ## $first ## [1] &quot;Abraham&quot; class(lst[1]) ## [1] &quot;list&quot; lst &lt;- list(1, 3, c(&quot;abc&quot;, &quot;ABC&quot;), list(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;), TRUE) lst[c(3, 1)] ## [[1]] ## [1] &quot;abc&quot; &quot;ABC&quot; ## ## [[2]] ## [1] 1 class(lst[c(3,1)]) ## [1] &quot;list&quot; Summary Factors are special types of vectors which are primarily used for categorical data. Factors can be ordered or unordered. We create factor objects using the factor() function. Lists are vectors which can have a mix of classes/types of objects. We create a factor or list using the functions factor() or list() We can use the same basic functions with factors and lists as we do with atomic vectors: length(), as.*(), is.*(), class() We have the same basic properties with factors and lists as we do with atomic vectors: length() determine how long an object is c() combine two objects of the same class together same naming techniques same indexing strategies We can also access individual elements of a list using [[]], which isolates an element and takes it out of the list structure. Additional Resources Chapters 4.10, 4.11 of Chapter 13 of “R for Programming in Data Science” Chapters Excercises Build a factor object with 3 levels, and 5 elements. Convert the directions vector above to a factor with the levels North, west, East, South. What happened to the values for West? Can we convert a logical vector into a factor vector? What about the other way around? Create a list with four elements: a character vector of length 2 that contains your first and last name a numeric vector of length 1 that contains your age a factor object from somewhere in this chapter an object of your choice Adjust/redefine your list in (4) so that way it is a named list. "],["matrices-data-frames-and-more.html", "Chapter 4 Matrices, Data Frames, and More 4.1 Matrices 4.2 Data Frames 4.3 Basic Features of Matrices/Data-Frames 4.4 Other Object Types and the Global Environment Summary", " Chapter 4 Matrices, Data Frames, and More 4.1 Matrices A matrix is a two dimensional array of data of the same type. The matrix function, matrix(), can be used to create a new matrix. m &lt;- matrix(c(1, 9, 2, 0, 5, 7, 3, 8, 4), nrow=3, ncol=3) m ## [,1] [,2] [,3] ## [1,] 1 0 3 ## [2,] 9 5 8 ## [3,] 2 7 4 R labels the rows and columns for us in the output. The matrix is filled column-by-column using the elements of the vector created by the concatenate function. The matrix m above is a matrix composed of doubles (the atomic object). This is the default type of matrix R creates, and it is by far the most common matrix used. However, we can also create integer matrices, logical matrices, and character matrices. # Example of a matrix with logical values m_logical &lt;- matrix(c(T, T, T, F, F, F, T, T), nrow = 4, ncol = 2) m_logical ## [,1] [,2] ## [1,] TRUE FALSE ## [2,] TRUE FALSE ## [3,] TRUE TRUE ## [4,] FALSE TRUE 4.1.1 Vectorized Operations As with vectors, matrices can be used in arithmetic operations with scalars and other matrices of the same size. We still have all the same basic vectorized operations. m2 &lt;- m/2 m2 ## [,1] [,2] [,3] ## [1,] 0.5 0.0 1.5 ## [2,] 4.5 2.5 4.0 ## [3,] 1.0 3.5 2.0 m *m2 ## [,1] [,2] [,3] ## [1,] 0.5 0.0 4.5 ## [2,] 40.5 12.5 32.0 ## [3,] 2.0 24.5 8.0 4.2 Data Frames Like a matrix, a data frame is a rectangular array of values where each column is a vector. However, unlike a matrix, the columns can be different data types. We can create a set of vectors of the same length and use the data.frame() function to make a data frame object. age &lt;- c(1, 8, 10, 30, 31) gender &lt;- c(&quot;Female&quot;, &quot;Female&quot;, &quot;Male&quot;,&quot;Female&quot;,&quot;Male&quot;) married &lt;- c(FALSE, FALSE, FALSE, TRUE, TRUE) simpsons &lt;- data.frame(age, gender, married) simpsons ## age gender married ## 1 1 Female FALSE ## 2 8 Female FALSE ## 3 10 Male FALSE ## 4 30 Female TRUE ## 5 31 Male TRUE class(simpsons) ## [1] &quot;data.frame&quot; To see all the class of each column in a data frame we can use the following command. sapply(simpsons, class) ## age gender married ## &quot;numeric&quot; &quot;character&quot; &quot;logical&quot; 4.2.1 Column Names Data frames always have column names. In the example above we used vectors to create a data frame. When we use this technique then the name of the vector is automatically selected as the column name. If we have inputted a vector like c(1, 2, 3, 4, 5) as an argument in the data.frame() function instead of an object name, then R would have guessed what to name the column. Matrices do not have this property. Matrices do not usually have column or row names (but they can, as we will see below). In contrast, data frames always have column names, and often have row names too. In the following section we discuss how to change the row and column names of both matrices and data frames explicitly. 4.3 Basic Features of Matrices/Data-Frames 4.3.1 Dimensions To access and determine the size or dimensions of a matrix and data frame there are three important functions. We no longer would want to use the length() function because that is for 1-dimsional objects. Since matrices and data frames are 2-dimensional objects we now must consider both dimensions. The three functions we can use to do this are dim(), nrow(), and ncol(). The dim() function returns the number of rows and the number of columns. The nrow() just returns the number of rows, and ncol() just returns the number of columns. dim(simpsons) ## [1] 5 3 nrow(simpsons) ## [1] 5 ncol(simpsons) ## [1] 3 4.3.2 Accesing Elements Indices can be used to obtain the elements of a matrix and data frame, but now we must consider both the row and column. We can access an individual point in a matrix or data frame using [row, colum], where row is the row index and column is the column index. m &lt;- matrix(c(1, 9, 2, 0, 5, 7, 3, 8, 4), nrow=3, ncol=3) m[2,2] ## [1] 5 We can access multiple elements using the c() function. Note we must use the c() function to separate the rows and columns we are trying isolate because the common inside the single brackets separates the dimensions. # Isolate multiple individual points. m[c(1,3), c(1,3)] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 We can also isolate entire rows or columns by leaving one of the dimensions blank. # Isolate the second row m[2,] ## [1] 9 5 8 # Isolate the third column m[,3] ## [1] 3 8 4 We can think of these individual rows or columns as an individual vector. vec &lt;- simpsons[,2] vec ## [1] &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; 4.3.3 Coercion We often do not need to convert matrices and data frames, but if we do we can use the as.matrix() or as.data.frame() on a pre-existing object to convert it into a matrix or data frame. The most common type of coercion that we have for 2-dimensional objects is changing the class of a column in a data frame. To do this we can redefine this class explicitly using indexing. # Changing the class of a single column simpsons[, 1] &lt;- as.factor(simpsons[, 1]) sapply(simpsons, class) ## age gender married ## &quot;factor&quot; &quot;character&quot; &quot;logical&quot; simpsons ## age gender married ## 1 1 Female FALSE ## 2 8 Female FALSE ## 3 10 Male FALSE ## 4 30 Female TRUE ## 5 31 Male TRUE 4.3.4 Testing/Class We can test or determine what type of object we have using the class() function. Again, this function will always return something for a given object. If we have a data frame or matrix it will return “data.frame” or “matrix”, respectively. We can also use the is.matrix() or is.data.frame() functions which will return TRUE/FALSE values. 4.3.5 Names With both matrices and data frames we can name the rows and columns. Data frames will always have column names, but matrices do not have to have them. It is very commmon to name the rows and columns for a data frame, but not as common for matrices. Matrices are most often used for linear algebra calculations. To see the row or column names of a 2-dimensional object we can use the rownames() and colnames() functions. rownames(simpsons) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; colnames(simpsons) ## [1] &quot;age&quot; &quot;gender&quot; &quot;married&quot; To change these names we use the same functions, and just manually reassign the values for them. rownames(simpsons) &lt;- c(&quot;Maggie&quot;, &quot;Lisa&quot;, &quot;Bart&quot;, &quot;Marge&quot;, &quot;Homer&quot;) simpsons ## age gender married ## Maggie 1 Female FALSE ## Lisa 8 Female FALSE ## Bart 10 Male FALSE ## Marge 30 Female TRUE ## Homer 31 Male TRUE colnames(simpsons) &lt;- c(&quot;Age&quot;, &quot;Gender&quot;, &quot;Married&quot;) simpsons ## Age Gender Married ## Maggie 1 Female FALSE ## Lisa 8 Female FALSE ## Bart 10 Male FALSE ## Marge 30 Female TRUE ## Homer 31 Male TRUE 4.4 Other Object Types and the Global Environment There are more objects then what we have discussed above. For example, many of the advanced functions create specific objects generated by that specific function. There are hundreds, and possibly thousands, of such objects. These objects generally are special cases of lists, factors, and other various types of objects that we have defined in this section. The objects we have described here are the building blocks of most values we will be working with. Functions like class() and length() are also considered as objects, but are of a different type. We discuss functions in more detail in section 7. There are also built-in, or special objects in R. For example, the object pi is an object already defined. These built-in values and functions can be written over, but that is not advised. pi ## [1] 3.141593 Every time we create an object we see that the Global Environment tab in the top right pane updates. The object we have created is now listed in the Global Environment. This is a collection of all user created objects in R, that R knows about, and that R can easily call. Built-in objects, such as pi, will not be listed here. Summary The basic and most common 2-dimensional objects are matrices and data frames. Matrices must contain all data of the same type. Data frames can have different classes between columns, and always have column names. We can create a matrix or data frame using the matrix() and data.frame() functions. Many vectorized operations still work for 2-dimensional objects. We can look at and name both rows and columns using rownames() and colnames(). To see the dimensions of a 2-dimensional object we use dim(), nrow() and ncol(). We can check if we have a matrix or data frame by using class() or is.*(). To access elements of a 2-dimsional object we use [row, column]. "],["indexing.html", "Chapter 5 Indexing 5.1 Atomic Vectors and Factors 5.2 Lists 5.3 Matrices 5.4 Data frames 5.5 Features and Applications Summary", " Chapter 5 Indexing When we wish to extract elements of an object like a vector, list, data frame, or matrix, we use a process called indexing. The process of indexing, is also sometimes called subsetting. In R the index of an object is the numeric location of that object. For example, consider the vector vec &lt;- c(100, 20, 3). The index of the first element is 1, the index of the second element is 2, and the so on. We have already seen a few examples of indexing for vectors and factors, lists, and 2D objects. In this section we more formally describe a plethora of indexing techniques. Indexing can be hard to master in R because of the many options, and the different types of objects. In this section we will describe the basic indexing techniques for atomic vector and factors, lists, matrices, and data frames. The indexing between the methods are all related, so it useful to talk about them all together. At the end of this section we give examples of a few features and applications we can do with indexing. 5.1 Atomic Vectors and Factors We have already seen a little big of indexing with vectors (atomic, factors, and lists). Now we will discuss indexing in more detail for 1D Objects. We will focus specifically on atomic vectors. The techniques here can be used with other types and classes of vectors though. For indexing with vectors we only have one indexing operator, []. We also have four general strategies that we will focus on. Suppose we wish to preform indexing on a vector vec. # Generate a random vector with the following code set.seed(10) vec &lt;- sample(1:100, 10) # numeric vector with 10 values vec ## [1] 9 74 76 55 72 54 39 83 88 15 Four basic strategies: positive integer: When using the positive integer strategy we use a vector index which only contains positive integers of the indexes. This vector can be of any positive finite length. That means it can be of length 1, length 10, or even length 10000. We use this operator by calling vec[index], which will return the elements of vec by their indices as ordered from index. negative integer: The negative integer strategy works similarly. This time we consider a vector index which only contains negative integers, and must have a positive length between 1 and the length of vec. These correspond to the elements of vec you would like to exclude. logical elements: When using the logical strategy we use a vector index which contains only logical (TRUE/FALSE) values. In this strategy index must be the same length as the vector vec. If it is not, R will use recycling to complete the command. The TRUE values in index represent the elements of vec you wish to keep, and FALSE values represent the elements you wish to exclude. names: If vec is a named vector we can also use the names to preform indexing. In this case the vector index should be a character vector where each element of the vector is the name of an element in vec that we wish to keep. We can not use a negative operator, or a negative sign with this strategy to exclude variables. We can not mix and max these strategies within a command. We can only use one strategy at a time. Example: Positive Integers # Obtaining a single element vec[1] ## [1] 9 # Obtaining several elements: Get 1st, 2nd, 3rd element vec[c(1, 2, 3)] ## [1] 9 74 76 # Get mutliples of the same element index &lt;- c(3, 2, 1, 1, 1, 2, 3) vec[index] ## [1] 76 74 9 9 9 74 76 Example: Negative Integers # Remove first element vec[1] ## [1] 9 # Remove several elements: 1st, 2nd, 3rd vec[-c(1, 2, 3)] ## [1] 55 72 54 39 83 88 15 # Equivalent to above index &lt;- c(-1, -2, -3) vec[index] ## [1] 55 72 54 39 83 88 15 Example: Logical Values # `index` should be the same length as `vec` index &lt;- c(T, T, T, T, F, F, F, F, F, T) vec[index] ## [1] 9 74 76 55 15 # When `index` is not of the same length as `vec`, we have recycling # Keeps every other element index &lt;- c(T, F) vec[index] ## [1] 9 76 72 39 88 Example: Names # Give names to each element in `vec` names(vec) = LETTERS[1:10] # Return Elements: A, B, D index = c(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;) vec[index] ## A B D ## 9 74 55 5.2 Lists Although lists are 1D objects, they have three different operators: [], [[]], and $. The first operator works the same way as we saw above for atomic vectors. We can use all four strategies we used in the prior section, and a new list will appear according to the indexing order. The new operators are [[]] and $, these operators are very similar. They both can only isolate one element in the list, and they return this element in its particular class. That is, if the second element in the list is data frame, then a data frame is returned with the [[]] and $ operators. 5.2.1 Double Brackets With the double brackets operator [[index]] we can put the index number for the element we want returned, or if we have a named list, we can put the name of the element we desire. Remember, you can only isolate one element in the list using this operator, so index must be of length 1. # Create a named list # Recall: name = value lst1 = list(first = c(&quot;Hello&quot;, &quot;Goodbye&quot;), second = c(1, 2, 3), third = c(T, F, T)) # Create a nested list with names lst2 = list(e1 = lst1, e2 = &quot;Stat 107 Rules&quot;) # See structure of the list str(lst2) ## List of 2 ## $ e1:List of 3 ## ..$ first : chr [1:2] &quot;Hello&quot; &quot;Goodbye&quot; ## ..$ second: num [1:3] 1 2 3 ## ..$ third : logi [1:3] TRUE FALSE TRUE ## $ e2: chr &quot;Stat 107 Rules&quot; # Isolate second element by name (maintains class of the element) lst2[[&quot;e2&quot;]] ## [1] &quot;Stat 107 Rules&quot; class(lst2[[&quot;e2&quot;]]) ## [1] &quot;character&quot; # Isolate second element by integer (maintains class of the element) lst2[[2]] ## [1] &quot;Stat 107 Rules&quot; class(lst2[[2]]) ## [1] &quot;character&quot; # Isolate nested elements lst2[[1]][[2]] ## [1] 1 2 3 5.2.2 Dollar Sign After the dollar sign operator $ we put the name of the desired element. You can only isolate one element in the list using this operator, and you can only access elements using their names. However, if you have # Isolate second element by name (maintains class of the element) lst2$e2 ## [1] &quot;Stat 107 Rules&quot; # Isolate nested elements lst2$e1$second ## [1] 1 2 3 You can also mix and match indexing methods for lists. lst1$second[2] ## [1] 2 5.3 Matrices For matrices we will only consider three indexing techniques, these are by far the most popular. There is only one operator we need to consider for matrices, and it is the same one we use for vectors []. Inside this operator you can put in two vectors, or a single vector. 5.3.1 Two Vectors Using two vectors when indexing a list is by far the most common, and the recommended way to index a matrix. It is easy to read, and standard practice. For this technique you use [row, column], where row is a vector of index values of the rows you wish to isolate, and column is a vector of the index values of the columns you wish to isolate. The vectors row and column support positive integers, negative integers, logical vectors, and character vectors with row and column names. That is, we can index the rows and columns of a matrix in the same way we did before with standard vectors, but now we have two dimensions to consider. Like before, the vectors row and column must be all positive values, all negative values, all logical, or only contain the respective names. However, the values between vectors can differ. For example, row can be a vector of positive integers, and column can be a vector of logical values. In general, a matrix returns another matrix, or it returns a vector. my_m = matrix(1:9, nrow = 3, ncol = 3) colnames(my_m) = c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;) my_m ## C1 C2 C3 ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Obtain a full row my_m[1,] ## C1 C2 C3 ## 1 4 7 # Obtain a full column my_m[,2] ## [1] 4 5 6 # All rows but the first, and get the last two columns my_m[-1, c(&quot;C2&quot;, &quot;C3&quot;)] ## C2 C3 ## [1,] 5 8 ## [2,] 6 9 5.3.2 Single Vector Matrices can be thought of as a special shaped atomic vector where the first elements of the vector are the first column (from top to bottom), the next elements are the second column (top to bottom), and so on. In fact, R supports indexing matrices using this idea. If attempt to subset a matrix using [index], where index is a single vector, then the values of index will correspond register the values of the matrix in this order. It is not particularly common to index in this way, and not recommended because it is not particularly clear. my_m[1] ## [1] 1 my_m[c(1, 9)] ## [1] 1 9 my_m[-c(1, 9)] ## [1] 2 3 4 5 6 7 8 5.4 Data frames Data frames can be indexed in all the ways that matrices can be indexed above. They also have a few more techniques. At its core, can think of data frames as a special type of list in which each element of the list is a vector of the same length. Data frames have three indexing operators [], [[]], and $. The [] operator works identically for data frames, as it does matrices, that is we can supply this operator two vectors [row, column] or one [index]. Thus, we will focus on the other two operators. Recall from indexing lists that [[]] and $ can only access one element of a list. When using [[]] and $ on data frames these operators can only access one column. Example: Double brackets # Use Built In Data Set: Iris head(iris) # Preview Data Set ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa sapply(iris, class) # Class of Each Column ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;factor&quot; summary(iris) # Summary Statistics of Each Column ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.057 Mean :3.758 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## Species ## setosa :50 ## versicolor:50 ## virginica :50 ## ## ## # Isolate column with positive integer # Returns a vector, not a data frame with one column iris[[1]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 # Isolate column with name (Same as above) # Returns a vector, not a data frame with one column iris[[&quot;Sepal.Length&quot;]] ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 Example: Dollar Sign # Isolate column with name (Same as above) # Returns a vector, not a data frame with one column iris$Sepal.Length ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 5.5 Features and Applications In this section we will go over some features and applications of using indexing techniques. These are special functions and things that we can do with the indexing we dicussed so far. 5.5.1 Indexing and Reassignment Recall the vector vec we created above. With all of the indexing techniques we discussed before, we can combine indexing with reassignment. We can reassign values inside of a vector via their index number. This can be done with all the objects and techniques we have learned. For example, recall the vector vec we created above. We can reassign the first three elements of vec to be 62. # `vec` from above # Generate a random vector with the following code set.seed(10) vec &lt;- sample(1:100, 10) # numeric vector with 10 values vec ## [1] 9 74 76 55 72 54 39 83 88 15 # reassign first three values of vec using index vec[1:3] &lt;- 62 vec ## [1] 62 62 62 55 72 54 39 83 88 15 The only values that are changed are the ones we isolated via indexing. Lets see another example with logical values. In this example we use the logical indexing technique to isolate only values that meet a certain condition. So the vector index_to_change contains logical values where TRUE indicates that the values in vec are greater than 50, and FALSE if otherwise. So when we use vec_chr[index_to_change] it changes all elements which correspond to TRUE to be equal to Big. It does not update any other elements in the vector vec_chr. # Make a character vector vec_chr &lt;- as.character(vec) # Reassign elements to &quot;Big&quot; if they are a big number # Do not change other elements index_to_change &lt;- vec&gt;50 vec_chr[index_to_change] &lt;- &quot;Big&quot; vec_chr ## [1] &quot;Big&quot; &quot;Big&quot; &quot;Big&quot; &quot;Big&quot; &quot;Big&quot; &quot;Big&quot; &quot;39&quot; &quot;Big&quot; &quot;Big&quot; &quot;15&quot; Here is another example where we reassign a column name of the matrix my_m to be “my_c2”. # Recall matrix my_m ## C1 C2 C3 ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # Reassign just one column name colnames(my_m)[2] &lt;- &quot;my_c2&quot; Now lets reassign the value in the second row, second column to be NA. my_m[2, &quot;my_c2&quot;] &lt;- NA my_m ## C1 my_c2 C3 ## [1,] 1 4 7 ## [2,] 2 NA 8 ## [3,] 3 6 9 5.5.2 Ordering/Integer Indexing As we saw above, we can also using indexing with positive integers and names to rearrange values in an object. If we want to do a rearrangement based on smallest to largest value (or vice versa), or alphabetical (or reverse alphabetical), we can do this directly with the order() function. This function returns the ranks of the variable being sorted. # Example data frame group = c(&quot;G1&quot;, &quot;G2&quot;, &quot;G1&quot;, &quot;G1&quot;, &quot;G2&quot;) age = c(35, 30, 31, 28, 40) height = c(65, 70, 60, 72, 68) pets = c(TRUE, TRUE, FALSE, FALSE, TRUE) mydata = data.frame(group, age, height, pets) mydata ## group age height pets ## 1 G1 35 65 TRUE ## 2 G2 30 70 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 5 G2 40 68 TRUE # Indices in smallest to largest order order(mydata$age) ## [1] 4 2 3 1 5 # Rearrange data frame to be from shortest to tallest mydata[order(mydata$age),] ## group age height pets ## 4 G1 28 72 FALSE ## 2 G2 30 70 TRUE ## 3 G1 31 60 FALSE ## 1 G1 35 65 TRUE ## 5 G2 40 68 TRUE mydata[order(mydata$group, mydata$age),] ## group age height pets ## 4 G1 28 72 FALSE ## 3 G1 31 60 FALSE ## 1 G1 35 65 TRUE ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE We can sort by more than one variable. Including more than one variable allows a “nested sort,” where the second variable, third variable, etc., is used when there are ties in the sorting based on the previous variables. Let’s first sort by group alone, and then by group followed by age and see what we get. # Sort just by &quot;group&quot; mydata[order(mydata$group), ] ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE # Rearrange data frame FIRST by &quot;group&quot;, SECOND by &quot;age&quot; mydata[order(mydata$group, mydata$age), ] ## group age height pets ## 4 G1 28 72 FALSE ## 3 G1 31 60 FALSE ## 1 G1 35 65 TRUE ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE To reorder a vector from smallest to largest we can also consider the sort() function. sort(mydata$age) ## [1] 28 30 31 35 40 5.5.3 Adding Elements/Rows/Columns To add an element/row/column to an object we can also use indexing and the assignment operator. To do so, we put the new index number or index name with our indexing operator, and assign a value. This only works when the new index number is only one more then current length or dimensions. # Adding an element to vec vec[length(vec)+1] &lt;- 1000 vec ## [1] 62 62 62 55 72 54 39 83 88 15 1000 # Adding a column to data frame Iris iris$new_column &lt;- &quot;Hello&quot; iris[1:10,] # Output first ten rows to preview ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_column ## 1 5.1 3.5 1.4 0.2 setosa Hello ## 2 4.9 3.0 1.4 0.2 setosa Hello ## 3 4.7 3.2 1.3 0.2 setosa Hello ## 4 4.6 3.1 1.5 0.2 setosa Hello ## 5 5.0 3.6 1.4 0.2 setosa Hello ## 6 5.4 3.9 1.7 0.4 setosa Hello ## 7 4.6 3.4 1.4 0.3 setosa Hello ## 8 5.0 3.4 1.5 0.2 setosa Hello ## 9 4.4 2.9 1.4 0.2 setosa Hello ## 10 4.9 3.1 1.5 0.1 setosa Hello # Adding another new column to Iris iris[, (ncol(iris)+1)] &lt;- &quot;Goodby&quot; iris[1:10,] # Output first ten rows to preview ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species new_column V7 ## 1 5.1 3.5 1.4 0.2 setosa Hello Goodby ## 2 4.9 3.0 1.4 0.2 setosa Hello Goodby ## 3 4.7 3.2 1.3 0.2 setosa Hello Goodby ## 4 4.6 3.1 1.5 0.2 setosa Hello Goodby ## 5 5.0 3.6 1.4 0.2 setosa Hello Goodby ## 6 5.4 3.9 1.7 0.4 setosa Hello Goodby ## 7 4.6 3.4 1.4 0.3 setosa Hello Goodby ## 8 5.0 3.4 1.5 0.2 setosa Hello Goodby ## 9 4.4 2.9 1.4 0.2 setosa Hello Goodby ## 10 4.9 3.1 1.5 0.1 setosa Hello Goodby 5.5.4 Delete Elements/Rows/Columns If we wanted to completely delete a element in a vector we can use the assignment operator. # Recall the vector vec ## [1] 62 62 62 55 72 54 39 83 88 15 1000 vec_copy &lt;- vec # Strategy 2 - Redefine Object: Delete the third element of vec vec_copy &lt;- vec_copy[-3] vec_copy ## [1] 62 62 55 72 54 39 83 88 15 1000 This method also works the same way with 2D objects and lists. In addition we can also use NULL. Recall that NULL is used to completely delete an object, in contrast to NA, which removes the value but saves the space. # Strategy 1 - NULL: Delete a column iris$new_column &lt;- NULL iris[1:10, ] # Preview first 10 rows ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species V7 ## 1 5.1 3.5 1.4 0.2 setosa Goodby ## 2 4.9 3.0 1.4 0.2 setosa Goodby ## 3 4.7 3.2 1.3 0.2 setosa Goodby ## 4 4.6 3.1 1.5 0.2 setosa Goodby ## 5 5.0 3.6 1.4 0.2 setosa Goodby ## 6 5.4 3.9 1.7 0.4 setosa Goodby ## 7 4.6 3.4 1.4 0.3 setosa Goodby ## 8 5.0 3.4 1.5 0.2 setosa Goodby ## 9 4.4 2.9 1.4 0.2 setosa Goodby ## 10 4.9 3.1 1.5 0.1 setosa Goodby # Strategy 2 - Redefine Object: Delete a column iris &lt;- iris[, -ncol(iris)] iris[1:10, ] # Preview first 10 rows ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa 5.5.5 Select Based on Condition So far we have not used logical vectors to index that much yet. Logical indexing is actually very helpful and common! One of the big reasons we use logical vectors for indexing is to select elements that meet a certain condition. For example, maybe we want only want to display elements of a vector that are larger than 50. # diplays elements of vec that are larger than 50 vec[vec &gt; 50] ## [1] 62 62 62 55 72 54 83 88 1000 We can also reassignment elements of a vector that meet a certain condition. This uses ideas from 5.5.1. # Reassign values in vec2 to be NA if they are greater than 50. vec2 &lt;- vec vec2[vec2&gt;50] &lt;- NA vec2 ## [1] NA NA NA NA NA NA 39 NA NA 15 NA We can of course also use this strategy on all other objects that support the [] operator, which is everything so far! # display rows of iris that have species == &quot;setosa&quot; iris[iris$Species==&quot;setosa&quot;, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 11 5.4 3.7 1.5 0.2 setosa ## 12 4.8 3.4 1.6 0.2 setosa ## 13 4.8 3.0 1.4 0.1 setosa ## 14 4.3 3.0 1.1 0.1 setosa ## 15 5.8 4.0 1.2 0.2 setosa ## 16 5.7 4.4 1.5 0.4 setosa ## 17 5.4 3.9 1.3 0.4 setosa ## 18 5.1 3.5 1.4 0.3 setosa ## 19 5.7 3.8 1.7 0.3 setosa ## 20 5.1 3.8 1.5 0.3 setosa ## 21 5.4 3.4 1.7 0.2 setosa ## 22 5.1 3.7 1.5 0.4 setosa ## 23 4.6 3.6 1.0 0.2 setosa ## 24 5.1 3.3 1.7 0.5 setosa ## 25 4.8 3.4 1.9 0.2 setosa ## 26 5.0 3.0 1.6 0.2 setosa ## 27 5.0 3.4 1.6 0.4 setosa ## 28 5.2 3.5 1.5 0.2 setosa ## 29 5.2 3.4 1.4 0.2 setosa ## 30 4.7 3.2 1.6 0.2 setosa ## 31 4.8 3.1 1.6 0.2 setosa ## 32 5.4 3.4 1.5 0.4 setosa ## 33 5.2 4.1 1.5 0.1 setosa ## 34 5.5 4.2 1.4 0.2 setosa ## 35 4.9 3.1 1.5 0.2 setosa ## 36 5.0 3.2 1.2 0.2 setosa ## 37 5.5 3.5 1.3 0.2 setosa ## 38 4.9 3.6 1.4 0.1 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 40 5.1 3.4 1.5 0.2 setosa ## 41 5.0 3.5 1.3 0.3 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 44 5.0 3.5 1.6 0.6 setosa ## 45 5.1 3.8 1.9 0.4 setosa ## 46 4.8 3.0 1.4 0.3 setosa ## 47 5.1 3.8 1.6 0.2 setosa ## 48 4.6 3.2 1.4 0.2 setosa ## 49 5.3 3.7 1.5 0.2 setosa ## 50 5.0 3.3 1.4 0.2 setosa 5.5.6 Convert Indexing Techniques With all these methods it can sometimes be difficult to remember which is which. However, we will often find ourselves naturally gravitating to one technique over another. There are different operators and functions in R that help us convert the different techniques. For example, the which() function helps us switch from logical indexing to positive integer indexing. # Switch from logical strategy, to positive integer strategy index = which(vec &gt;50) index ## [1] 1 2 3 4 5 6 8 9 11 vec[index] ## [1] 62 62 62 55 72 54 83 88 1000 The %in% operator helps us make a check if elements in the object values are in the set keep, i.e. values %in% keep. # Returns logical vector of column names to keep keep &lt;- c(&quot;species&quot;, &quot;Sepal.Length&quot;) colnames(iris) %in% keep ## [1] TRUE FALSE FALSE FALSE FALSE Summary Indexing operators [], [[]], $ []: Used with 1d and 2d objects Positive Integers Negative Integers Name Logical [[]]: Used with lists or Data frames. Can only isolate one element or column. Positive Integers Name $: Used with lists or Data frames. Can only isolate one element or column. Name Indexing can be combined with reassignment. Some important functions and operators to remember: order(), sort(), which(), %in%. "],["working-with-data-sets.html", "Chapter 6 Working with Data Sets 6.1 Getting Data Sets in Our Working Environment 6.2 Basic Data Manipulation Summary", " Chapter 6 Working with Data Sets In this section we discuss different methods for loading data sets into our R session. There are many different files we can create and import. We will focus our attention on loading csv files because they tend to be easier to import, and they are one of the more typical file types that are used. In the second half of the this chapter we introduce some more basic data manipulation strategies and helpful functions when working with data sets beyond indexing. 6.1 Getting Data Sets in Our Working Environment Built-In Data As discussed last week, there are built in objects which are not loaded into the global environment, but can be called upon at any time. For example pi returns the value 3.1415927. Similarly, there are built in data sets that are ready to be used and loaded at a moments notice. To see a list of built in data sets type in the console: data() These data sets can be used even if they are not listed in the global environment. For example, if you would like to load the data set in the global environment, run the following command: data(&quot;cars&quot;) Importing From Your Computer Although built-in data sets are convient, most the time we need to load our own datasets. We load our own data sets by using a function specifically designed for the file type of interest. This function usually uses the file path location as an argument. This can be done in many different ways; however, we will only go over two. Option 1 Download the file InsectData.csv from ELearn. Save this file in a spot in your computer you will remember. In the Environment window (upper left window), click on the Import Dataset button. A drop down menu will appear. Select the From Text (base)… option. Find the file InsectData.csv and select it. A pop up menu will appear giving you options for loading in the file, and showing a preview of what the file will look like once loaded. Select the appropriate options and click Import. A new line of code has generated in the console which will read the data into your current environment. Copy and paste this into your R script document if you would like to save this line of code for later. You will have to reload this file into your environment each time you start a new R session and would like to use this file. Option 2 Download the file InsectData.csv from ELearn. Save this file in a spot in your computer you will remember. In the lower right hand window select the File tab. Now search for the file which you have saved InsectData.csv. Click on the file InsectData.csv in order to see a dropdown menu. Select Import Dataset… A window will appear which will give you options and a preview of your file. Select appropriate options if needed then click Import. A new line of code has generated in the console which will read the data into your current environment. Copy and paste this into your R script document if you would like to save this line of code for later. You will have to reload this file into your environment each time you start a new R session and would like to use this file. Import From Online We can also download data sets from online in a variety of different ways. Below is one option. With this method we are using the same InsectData.csv file, but it has been posted online. We feed the url of where the data set has been posted into the read.csv() function in order to open the file. the_url = &quot;https://raw.githubusercontent.com/rpkgarcia/LearnRBook/main/data_sets/InsectData.csv&quot; the_data = read.csv(the_url) 6.2 Basic Data Manipulation Lets recall a few useful things about data frames. As we learned already, data sets are contained in an object called a data frame. One can view this as a specialized table or matrix of rows and columns, where each column is a data variable, such as height or age, and each row is a single observation. All of the values within a column must be the same data type (numeric,factor, logical, etc.). Data frames can be created or called within R, imported from text or spreadsheet files, or imported from the web. group = c(&quot;G1&quot;, &quot;G2&quot;, &quot;G1&quot;, &quot;G1&quot;, &quot;G2&quot;) age = c(35, 30, 31, 28, 40) height = c(65, 70, 60, 72, 68) pets = c(TRUE, TRUE, FALSE, FALSE, TRUE) mydata = data.frame(group, age, height, pets) mydata ## group age height pets ## 1 G1 35 65 TRUE ## 2 G2 30 70 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 5 G2 40 68 TRUE The summary() function is a powerful command that gives you some summary statistics about the variables in the data frame. summary(mydata) ## group age height pets ## Length:5 Min. :28.0 Min. :60 Mode :logical ## Class :character 1st Qu.:30.0 1st Qu.:65 FALSE:2 ## Mode :character Median :31.0 Median :68 TRUE :3 ## Mean :32.8 Mean :67 ## 3rd Qu.:35.0 3rd Qu.:70 ## Max. :40.0 Max. :72 The summary statistics are listed below the names of the variables. Since pets is a logical variable, R gives you the frequencies of each unique value. In this example there are three values of TRUE and two values of FALSE. Since age and weight are numeric, R computes and returns the minimum, 1st quartile (25th percentile), median, mean, 3rd quartile (75th percentile), and maximum values. If you have many data values, this is a quick way to get a feel for how the data are distributed. Just like we did for vectors, we can also use the table() to cross-tabulate categorical data. Let’s create a frequency table for the different groups. table(mydata$group) ## ## G1 G2 ## 3 2 We can also create a frequency table of pet status for both groups. table(mydata$group, mydata$pets) ## ## FALSE TRUE ## G1 2 1 ## G2 0 2 Subset We already discussed how powerful indexing techniques can be, and various different ways to use indexing to subset a data set. We also have the subset() function which accomplishes much of the same tasks, and can be used as an alternative to many indexing operations. For example, we can subset a data frame by isolating all rows that belong to group “G1”. group1 = subset(mydata, mydata$group == &quot;G1&quot;) group1 ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE To subset by all values which are NOT equal to a condition we can use the logical operator !=. group2 = subset(mydata, mydata$group != &quot;G1&quot;) group2 ## group age height pets ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE Adding Columns One can add a new variable (column) to a data frame by defining a new variable and assigning values to it. Below we add a weight variable to the data frame. wghts = c(169, 161, 149, 165, 155) wghts ## [1] 169 161 149 165 155 mydata$weight = wghts mydata ## group age height pets weight ## 1 G1 35 65 TRUE 169 ## 2 G2 30 70 TRUE 161 ## 3 G1 31 60 FALSE 149 ## 4 G1 28 72 FALSE 165 ## 5 G2 40 68 TRUE 155 We can also add a new column using the cbind() function. mydata = cbind(mydata, wghts) mydata ## group age height pets weight wghts ## 1 G1 35 65 TRUE 169 169 ## 2 G2 30 70 TRUE 161 161 ## 3 G1 31 60 FALSE 149 149 ## 4 G1 28 72 FALSE 165 165 ## 5 G2 40 68 TRUE 155 155 NA values In addition, if we have a missing value, or a blank value, we can use the object NA to indicate the lack of a value. fav_color = c(&quot;Red&quot;, NA, &quot;Purple&quot;, NA, &quot;Red&quot;) mydata = cbind(mydata, fav_color) mydata ## group age height pets weight wghts fav_color ## 1 G1 35 65 TRUE 169 169 Red ## 2 G2 30 70 TRUE 161 161 &lt;NA&gt; ## 3 G1 31 60 FALSE 149 149 Purple ## 4 G1 28 72 FALSE 165 165 &lt;NA&gt; ## 5 G2 40 68 TRUE 155 155 Red We can drop check for NA values using the is.na() function. is.na(mydata) ## group age height pets weight wghts fav_color ## [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [3,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [4,] FALSE FALSE FALSE FALSE FALSE FALSE TRUE ## [5,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE We can remove all rows with NA values using na.omit(). na.omit(mydata) ## group age height pets weight wghts fav_color ## 1 G1 35 65 TRUE 169 169 Red ## 3 G1 31 60 FALSE 149 149 Purple ## 5 G2 40 68 TRUE 155 155 Red NULL One can drop a variable (column) by setting it equal to the R value NULL. mydata$wghts = NULL mydata ## group age height pets weight fav_color ## 1 G1 35 65 TRUE 169 Red ## 2 G2 30 70 TRUE 161 &lt;NA&gt; ## 3 G1 31 60 FALSE 149 Purple ## 4 G1 28 72 FALSE 165 &lt;NA&gt; ## 5 G2 40 68 TRUE 155 Red Be careful using these methods. Once a variable or row is dropped, it’s gone. Adding Rows Rows can be added to a data frame using the rbind() (row bind) function. Because our columns have different data types, we will create a list object and then add it as a new row. newobs = list(&quot;G1&quot;, 23, 62, FALSE, 160, &quot;Blue&quot;) newdata = rbind(mydata, newobs) newdata ## group age height pets weight fav_color ## 1 G1 35 65 TRUE 169 Red ## 2 G2 30 70 TRUE 161 &lt;NA&gt; ## 3 G1 31 60 FALSE 149 Purple ## 4 G1 28 72 FALSE 165 &lt;NA&gt; ## 5 G2 40 68 TRUE 155 Red ## 6 G1 23 62 FALSE 160 Blue We can also use rbind() to append one data frame to another. We can do this with the variables group1 and group2 created above still exist in your R environment. group1 ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE group2 ## group age height pets ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE rbind(group1, group2) ## group age height pets ## 1 G1 35 65 TRUE ## 3 G1 31 60 FALSE ## 4 G1 28 72 FALSE ## 2 G2 30 70 TRUE ## 5 G2 40 68 TRUE Summary How to get data Use default data sets data() Load csv files with read.csv() and read_csv() Download data from online Data manipulation functions to keep in mind table(), summary() subset() rbind(), cbind() na.omit(), is.na() "],["functions.html", "Chapter 7 Functions 7.1 Build Your Own Function 7.2 Lexical Scoping 7.3 Built-In Functions 7.4 Help Files 7.5 The … Argument 7.6 Generic Functions Additional Resources", " Chapter 7 Functions In R we have functions, functions are another type of object in R. We use functions in order to preform a series of tasks repeatedly, or preform these tasks in different settings. They can make our code much more efficient. We can build our own functions or we can use built in functions. Here we describe both types and their properties. Parts of this chapter where adapted by John Blischak, Daniel Chen, Harriet Dashnow, and Denis Haine (2016) and Vries and Meys (2015). 7.1 Build Your Own Function To define a function, a name is assigned and the keyword function is used to denote the start of the function and its argument list. Functions are created using the function() directive and are stored as R objects just like anything else. In particular, they are R objects of class function. Functions can be passed as arguments to other functions. Functions can be nested, so that you can define a function inside another function. Below is the general template function_name = function(arg){ # Function Body .... return(return_value) } In this template we have the following key components function_name: This is the actual name of the function. It is stored in R environment as an object with this name. function: A directive which tells R a function is being created. arg: An argument is a placeholder. When a function is invoked, you pass a value to the argument. Arguments are optional; that is, a function may contain no arguments. Also arguments can have default values. function body: The function body contains a collection of statements that defines what the function does. return_value: The output value of the function. If return(return_value) is not supplied then the return value of a function is the last expression in the function body to be evaluated. Your function can only return one object. This object can be any class of object you desire, like a vector, list or data frame, but you may only return one object. Below is an example of converting a temperature from Fahrenheit to Celsius. # Convert temperature from Fahrenheit (F) to Celsius (C) # ARGUMENTS: temp_F, a numeric vector of length 1 in F units # RETURNS: temp_C, a numeric vector of length 1 in C units fahrenheit_to_celsius = function(temp_F){ temp_C = (temp_F - 32) * 5 / 9 return(temp_C) } In this example the function name is fahrenheit_to_celsius, there is only one input or argument, temp_F, and the output is the object temp_C. Now if we would like to “call” this function we can simply put into the command console the function name and desired input. # Convert 87F to Celsius fahrenheit_to_celsius(temp_F = 87) ## [1] 30.55556 What would happen if we tried to call this function without supplying an input? This would result in an error. # temp_F not defined. fahrenheit_to_celsius() Error in fahrenheit_to_celsius() : argument &quot;temp_F&quot; is missing, with no default With functions we can define function arguments to have default values. These default values are used only if the user did not supply an argument value. Observe the example below. # An example function, does simply algebra # ARGUMENTS: a = 1 (default), a numeric vector of length 1 # b, a numeric vector of length 1 # RETURNS: d, a numeric vector of length 1 example_func = function(a = 1, b){ c = a + b d = c + 1 # returns a+b+1 return(d) } # Call example function example_func(a= 2, b= 3) ## [1] 6 example_func(b = 3) ## [1] 5 Further notice that R has three ways to match function inputs to the formal arguments of the function definition. R attempts to match inputs to arguements in the following order. by complete name by partial name (matching on initial n characters of the argument name) by position After running a function command R first attempts to match arguments by complete name, then by partial name, and then by position. If it unable to match inputs to an argument it then uses the default argument value, if one exists. Observe: example_func(2, 3) ## [1] 6 example_func(b = 3, a = 2) ## [1] 6 example_func(a = 2, b = 3) ## [1] 6 7.2 Lexical Scoping With all these examples of functions, notice that in your global environment, only the function name was added. The function arguments, return values, and all objects defined inside the function are not a part of the global environment. This is not a mistake. We can define objects locally, or temporarily, when using functions. These objects are created and used only when the function is running, and quickly discarded once the function finishes. They never are listed in the global environment. Sometimes you may have an object defined in multiple places. When this happens, R uses a system of rules to determine which definition it will use. In other words, how and where we define an object determines the objects scope, or range of places that we can use this object. The system of rules R uses for searching for objects is called lexical scoping, as opposed to other types of scoping. With this system R looks for objects that are called in a function within the itself, then any enclosing environments, then the global environment, and lastly looking at objects in packages or built-in objects. This is the same searching method that we see in Python and Java. 7.3 Built-In Functions R has functions built-in to it just like excel. You can call these built-in function at any time. We have already seen a few of these functions. c() class() matrix() data.frame() Below are a few more examples using the built-in dataset mtcars, we will use mtcars$mpg as a vector of data to analyze. mean(): Takes in a vector, and returns the mean of the values in the vector. mean(mtcars$mpg) ## [1] 20.09062 median(): Takes in a vector, and returns the median of the values in the vector. median(mtcars$mpg) ## [1] 19.2 var(): Takes in a vector, and returns the variance of the values in the vector. var(mtcars$mpg) ## [1] 36.3241 sqrt(): If you give it a vector, it returns the square root of each element in the vector. If you give it a single number, it returns the square root of the number. sqrt(mtcars$mpg) ## [1] 4.582576 4.582576 4.774935 4.626013 4.324350 4.254409 3.781534 4.939636 ## [9] 4.774935 4.381780 4.219005 4.049691 4.159327 3.898718 3.224903 3.224903 ## [17] 3.834058 5.692100 5.513620 5.822371 4.636809 3.937004 3.898718 3.646917 ## [25] 4.381780 5.224940 5.099020 5.513620 3.974921 4.438468 3.872983 4.626013 sd(): Takes in a vector, and returns the standard deviation of the values in the vector. sd(mtcars$mpg) ## [1] 6.026948 range(): Takes in a vector, and returns the minimum AND maximum of the values in the vector. range(mtcars$mpg) ## [1] 10.4 33.9 quantile(): Takes in a vector as the first argument, and a vector of values between 0 and 1 (any number of values) for the second argument. It will return the corresponding quantiles of the values in the first vector specified by the second vector. To get the \\(10^{th}\\) and \\(90^{th}\\) percentiles: quantile(mtcars$mpg,c(0.10,0.90)) ## 10% 90% ## 14.34 30.09 summary(): You can give this a dataset OR a vector. It returns some summary information about the values in the dataset or vector. summary(cars$speed) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.0 12.0 15.0 15.4 19.0 25.0 One of the great advantages of using R is that there is a ton of resources available to learn about it. However, this can also be a disadvantage because of the vast amount of information available. The best and first resource you should look at when trying learn more about R functions is the Help files. 7.4 Help Files The Help files are in R and can be viewed from the lower right window by clicking the Help tab. Here you can search by function name to read about it. Each built in function has a help files, sometimes similar functions are grouped together in the same file. The R Help Files are typically the best resource to get help. The R Help files follow a fairly standard outline. You find most of the following sections in every R Help file: Title: A one-sentence overview of the function. Description: An introduction to the high-level objectives of the function, typically about one paragraph long. Usage: A description of the syntax of the function (in other words, how the function is called). This is where you find all the arguments that you can supply to the function, as well as any default values of these arguments. Arguments: A description of each argument. Usually this includes a specification of the class (for example, character, numeric, list, and so on). This section is an important one to understand, because arguments are frequently a cause of errors in R. Details: Extended details about how the function works, provides longer descriptions of the various ways to call the function (if applicable), and a longer discussion of the arguments. Value: A description of the class of the value returned by the function. See also: Links to other relevant functions. In most of the R editors, you can click these links to read the Help files for these functions. Examples: Worked examples of real R code that you can paste into your console and run. An alternative way to view a functions help file is by typing ? followed by the function name, or by typing help(function_name). # Find a help file for the function `rep` ?rep help(rep) If you are not sure exactly which function you want, you can use ?? followed by what you believe the function name is to look at a list of functions. ??rep 7.5 The … Argument There is a special argument function ... that can be used. Sometimes we call a function within a function that has a different set of arguments. We can use the ... argument as a general placeholder for passing along any additional arguments in a function call. # An example function, uses the ... argument and calls fun2() # ARGUMENTS: x , a numeric vector of length 1 # ..., all additional arguments to be passed to fun2() # RETURNS: z, a numeric vector of length 1 fun1 = function(x, ...){ y = fun2(...) z = x + y return(z) } # Support function for fun1() # ARGUMENTS: a , a numeric vector of length 1 # RETURNS: b, a numeric vector of length 1 fun2 = function(a){ b = a^2 return(b) } # Returns 1 + 2^2 = 5 fun1(1, 2) ## [1] 5 We can also use the ... arguement in a nested fashion. # An example function, uses the ... argument and calls fun2() # ARGUMENTS: x , a numeric vector of length 1 # ..., all additional arguments to be passed to fun2() # RETURNS: z, a numeric vector of length 1 fun1 = function(x, ...){ y = fun2(...) z = x+ y return(z) } # Support function for fun1(), calls fun3() # ARGUMENTS: a , a numeric vector of length 1 # ..., all additional arguments to be passed to fun3() # RETURNS: c, a numeric vector of length 1 fun2 = function(a, ... ){ b = fun3(...) c = a^2 + b return(c) } # Support function for fun1() and fun2(), called by fun2() # ARGUMENTS: n , a numeric vector of length 1 # RETURNS: n, a numeric vector of length 1 fun3 = function(n){ n = sqrt(n) return(n) } # Returns: 1 + 2^2 + sqrt(4) = 7 fun1(1, 2, 4) ## [1] 7 # Returns: 1 + 2^2 + sqrt(4) = 7 # Define each input explicitly fun1(x = 1, a = 2, n = 4) ## [1] 7 When using the ... argument it is customary to always place ... at the end of a function argument list, as it can be difficult for R to determine which arguments are to be passed to the next function. If possible, it is good practice to explicitly define the arguments to avoid an error. 7.6 Generic Functions In R we have something called generic functions which are functions that behave differently depending on the class type of one of the arguments. Typically generic functions depend on the class of the first argument. The functions mean(), summary(), and plot() are all generic functions. These functions act as a “middle man” or a “dispatcher”. The generic function calls the actual function you desire. For example, when we call summary() and the first argument is a lm object, then the summary function that is actually run is summary.lm() which may have its own help file. Additional Resources Chapter 14 of “R for Programming in Data Science” Chapter 13 of “Advanced R” Videos: R Functions 1 | Anatomy of a Function R Functions 2 | Getting Help R Functions 3 | Argument Order and Default Values Writing Functions 1 | Introduction Writing Functions 2 | 4 Fundamental Steps "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
