[["index.html", "STAT 107 Outline of Class Notes Welcome", " STAT 107 Outline of Class Notes Rebecca Kurtz-Garcia 2022-07-23 Welcome Welcome to STAT 107! This document will contain and outline of the course notes throughout the quarter. Please see the course website for an approximate schedule. In each of the chapters there will be a list of links, resources, and videos for learning more about an individual topic. This document will be updated constantly, be sure to check here for periodic updates. In addition, this document does not serve as a substitute for in class instruction, but more as a guide for the general content we discuss. Students are still expected to attend every lecture. "],["introduction-to-r.html", "Chapter 1 Introduction to R 1.1 Download and Install R and Rstudio 1.2 The RStudio Interface 1.3 Comments 1.4 Operators 1.5 Naming Conventions Additional Resources", " Chapter 1 Introduction to R In this chapter we introduce R and RStudio, which you’ll be using throughout this course to learn how to analyze real data and come to informed conclusions. To straighten out which is which: R is the name of the programming language itself, and RStudio is a convenient interface for using R. As the course progresses, you are encouraged to explore beyond what we discuss; a willingness to experiment will make you a much better scientist and researcher. Before we get to that stage, however, you need to build some competence in R. We begin with some of the fundamental building blocks of R and Rstudio: the interface, data types, variables, importing data, and plotting data. R is widely used by the scientific community as a no-cost alternative to expensive commercial software packages like SPSS and MATLAB. It is both a statistical software analysis system and a programming environment for developing scientific applications. Scientists routinely make available for free R programs they have developed that might be of use to others. Hundreds of packages can be downloaded for all types of scientific computing applications. This chapter was written by the help of Desharnais2020. 1.1 Download and Install R and Rstudio To get started, you need to download both the R and Rstudio software. Both are available for free and there are versions for Linux, Mac OS X, and Windows. It is suggested that you download R first and then Rstudio. R can be used without RStudio, but RStudio provides a convenient user interface and programming environment for R. The details for downloading and installing these software packages varies depending on your computer and operating system. You may need permission to install the software on your computer. The links below provide access to a mirror archive at UCLA for downloading R and the developer’s site for downloading RStudio. To download R, go to the url https://ftp.osuosl.org/pub/cran. Choose the binary distribution appropriate for your computer. Windows users will want to click on the link to “Download R for Windows” and choose “install R for the first time,” then “Download R 3.5.2 for Windows.” Mac OS users will want to click “Download R for (Mac) OS X.” Download the install package for version R-3.5.2 If you are using Mac OS X 10.9-10.10, install version R-3.3.3. If you are using OS X 10.6-10.8, install version R-3.2.1. Linux users will want to click on the link to “Download R for Linux.” You will need to choose the version of Linux that corresponds to your installation. Versions are available for Debian, RedHat, SUSE, and Ubuntu. For RStudio, use the url https://www.rstudio.com/products/rstudio/download/. Choose the binary distribution appropriate for your computer. Installers are provided for a variety of platforms. For additional help please see this video: Getting Started 1 | How to Download and Install RStudio 1.2 The RStudio Interface We will begin by looking at the RStudio software interface. Launch RStudio. You will see a window that looks like the figure above. There are four panels of the window: The pane in the bottom left is the R Command Console is where you type R commands for immediate execution. The pane in the upper left portion of the window is an area for editing R source code for scripts and functions and for viewing R data frame objects. New tabs will be added as new R code files and data objects are opened. The pane in the upper right portion of the window is an area for browsing the variables in the R workspace environment and the R command line history. The pane in the lower right portion of the window has several tabs. The Files tab is an area for browsing the files in the current working directory. The Plot tab is for viewing graphics produced using R commands. The Packages tab lists the R packages available. Other packages can be loaded. The Help tab provides access to the R documentation. The Viewer tab is for viewing local web content in the temporary session directory (not files on the web). Bottom Left Pane Let’s begin with the Console. This is where you type R commands for immediate execution. Click in the Command Console, “&gt;” symbol is the system prompt. You should see a blinking cursor that tells you the console is the current focus of keyboard input. Type: 1+2 ## [1] 3 The result tells you that the line begins with the first (and only) element of the result which is the number 3. You can also execute R’s built-in functions (or functions you add). Type the following command. exp(pi) ## [1] 23.14069 In R, “pi” is a special constant to represent the number and “exp” is the exponential function. The result tells you that the first (and only) element of the result is the number \\(e^{\\pi}=\\) 23.14069. Bottom Right Pane Now let’s look at the Files tab of the notebook at the lower right of the window. Every R session has a working directory where R looks for and saves files. It is a good practice to create a different directory for every project and make that directory the working directory. For example, let’s make a new directory called MyDirectory. (You can chose another name if you wish). Click on the Files tab of the notebook. You should see a listing of files in your default working directory. Click on the small button with an ellipsis image on the right side of the file path above the directory listing. Navigate to the folder where you want to create the new directory and click the OK button. Click on the New Folder button just below the Files tab (see right). Type MyDirectory in the panel that opens click on the folder in the Notebook. Click the More button to the right of the New Folder button and select the menu option Set as Working Directory. This new folder is now the working directory for the current R session. This menu option is a short cut for a command that was automatically entered into the R console. Top Right Pane Next we will look at the R environment, also called the R workspace. This is where you can see the names and other information on the variables that were created during your R session and are available for use in other commands. In the R console type: a = 29.325 b = log(a) c = a/b Look at the Environment pane. The variables a, b, and c are now part of your R work space. You can reuse those variables as part of other commands. In the R console type: v= c(a, b, c) v ## [1] 29.325000 3.378440 8.680041 The variable v is a vector created using the concatenate function c(). (The concatenate should not be confused with the variable c that was created earlier. Functions are always followed by parentheses that contain the function arguments.) This function combines its arguments into a vector or list. Look at the Environment panel. The text num [1:3] tells us that the variable v is a vector with elements v[1], v[2], and v[3]. Top Left Pane Now let’s look at the R viewer notebook. This panel can be used to data which are data frame objects or matrix objects in R. We will begin by taking advantage of a data frame object that was built into R for demonstration purposes. We will copy it into a data frame object. In the R console, type: df &lt;- mtcars Let’s view the data. On the right side of the entry for the df object is a button we can use to view the entries of the data frame. Click on the View Button. If your look in the notebook area in the upper left portion of the window, you can see a spreadsheet-like view of the data. This is for viewing only; you cannot edit the data. Use the scroll bars to view the data entries. You can also list the data in the console by typing the name of the data fame object: df ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 The columns are labeled with the names of the variables and the rows are labeled with the names of each car. Each row represents the data values for one car; that is, each row is one observation. 1.3 Comments Often times we will want to add a comment to our script document so we can remember special aspects later, and make the code easier to read and modify in the future. To add a comment start the comment with a # symbol. This will make the remaining characters in a line a comment and R will not try to compile these lines. Go to the script document and type the following. Highlight what you have typed and press “Run”. # This is a comment 2+ 2 ## [1] 4 2 + 3 # Comments can also start in the middle of a line. ## [1] 5 1.4 Operators An operator is a symbol that tells the compiler to preform a specific task. There are several types of operators, some preform mathematical tasks, logical checks, and create new objects. We will review a few of the basic operators here. We will continue to discuss and introduce operators throughout this document. Arithmetic Operators R was designed for statistical applications and as a necessity it needs to preform mathematical operations efficiently and effectively. The first operators we discuss are a few of the basic arithmetic operations. These are operations similar to that of a calculator. # Addition 2+ 3 ## [1] 5 # Subtraction 2 - 3 ## [1] -1 # Multiplication 2*3 ## [1] 6 # Division 2/3 ## [1] 0.6666667 # Exponent 2^3 ## [1] 8 Relational Operators Relational operators are used to compare two values. When using a relational operation R will return either TRUE or FALSE. # Less than 2 &lt; 3 ## [1] TRUE # Greater than 2 &gt; 3 ## [1] FALSE # Less than or equal to 2 &lt;= 3 ## [1] TRUE # Greater than or equal to 2&gt;= 3 ## [1] FALSE # Not equal to 2 != 3 ## [1] TRUE # Equal to 2 == 3 ## [1] FALSE We can use all the same operators above if our object contains more than one element. This will preform the above comparisons element by element. v ## [1] 29.325000 3.378440 8.680041 v &gt; 10 ## [1] TRUE FALSE FALSE If we have two vectors of an unequal length then the checks will be preformed element-by-element but the values in the shorter vector will be recycled, or repeated. w = c(10, 1) v &gt; w ## Warning in v &gt; w: longer object length is not a multiple of shorter object ## length ## [1] TRUE TRUE FALSE R evaluated the first and third element of v and compared it to the first element of w, and the second element of v to the second element of w. In this case, R returned a warning alerting you that it recycled elements. However, R will not always give a warning. Logical operators Logical operators are similar to relational operators. They are used to check “AND” and “OR” events. We have the &amp; symbol which returns TRUE only if BOTH conditions are true. We also have the | symbol which returns TRUE if EITHER condition is true. # Check if both operations are true. (2 &lt; 3) &amp; (5 &lt; 4) ## [1] FALSE # Check if either operation is true. (2 &lt; 3) | (5 &lt; 4) ## [1] TRUE We can also negate a TRUE or FALSE value using the ! symbol. # Negate an operation !(2&lt;3) ## [1] FALSE Like relational operators from before, if we have more than one element the logical operations will be implemented element-by-element. # AND event, compared element-by-element (v &gt; 10) &amp; (4 &lt; 5) ## [1] TRUE FALSE FALSE # OR event, compared elmeent-by-elment (v &gt; 10) | (4 &lt; 5) ## [1] TRUE TRUE TRUE We also have the symbols &amp;&amp; and || which will ensure that only the first element in an object will be compared. # AND event, only check the first element (v &gt; 10) &amp;&amp; (4 &lt; 5) ## [1] TRUE # OR event, only check the first element (v &gt; 10) || (4 &lt; 5) ## [1] TRUE Assignment Operators Assignment operators are used to assign values to a new object. There are many types of assignment operators, and they operate slightly differently. The two most common assignment operators are = and &lt;-. With these operators the value to the left of the operator is the name of the new object and the value on the right is what the object is now equal to. x = 5 x ## [1] 5 x &lt;- 5 x ## [1] 5 The majority of the time we can use these two assignment operators above interchangeably, there are some exceptions though. There are several other assignment operators which are uncommon and should only be used by advanced users, -&gt;, &lt;&lt;-, and -&gt;&gt;. When we create new objects it is called binding. Consider the code below. v &lt;- c(6, 2, 5) In this line of code the object c(6, 2 ,5) is binded to the name v. That is, v acts as a reference (or a placeholder) for the object c(6, 2, 5). Everywhere we see the object v we should mentally replace it with this vector. 1.5 Naming Conventions R has rules when it comes to naming objects. An object may start with a letter or a ., and the remaining characters may consist of letters, digits, . or _. There are also special types of objects that have already established names in R. For example, NULL, TRUE, FALSE, if, and function should not be used as a new object name. To see a list of these reserved object names type ?Reserved in to your console. Additional Resources Chapter 1 of “CRAN Intro-to-R Manual” Videos: Getting Started 1 | How to Download and Install RStudio Getting Started 2 | Rstudio Introduction cont’d, More Tabs Explained "],["atomic-vectors.html", "Chapter 2 Atomic Vectors 2.1 Examples 2.2 Basic Features Summary Additional Resources", " Chapter 2 Atomic Vectors At its core, R is an objected-oriented computational and programming environment. Everything in R is an object with different properties. In this chapter we will go over vectors, these are the core fundamental objects used in R. A vector in R is a 1-dimensional object. That is, it contains a sequence of elements in a particular order. For example, v &lt;- c(2, 6, 5) is a vector with three elements. The first element is a 2, the second is a 6, and third is a 5. An object with just a single element, w &lt;- 3 is just a vector with only one value. R can represent different types of data. The types include double, integer, complex, logical, character, and raw. These are the basic fundamental objects we can use in R and are referred to as the atomic values. For our class we will not need the complex type which stores complex numbers, and in practice raw is rarely used. We will concentrate on the remaining four types. Unlike other object-oriented languages we do not need to specify what type of object we are creating when we create it. Instead, R guesses the type of object you are creating. To create an atomic vector we use the concatenate function c(), where each element of the vector is separated by a comma. This function will always create an atomic vector. double: A vector of real numbers (numbers which may contain decimal values). We can create these vectors using decimal (12.34) or scientific form (.1234e2). When using numbers this is the default type used. integer: A vector of integers (whole numbers). We can create these vectors using a integer followed by a letter L, i.e. 5L. logical: A vector containing only TRUE or FALSE values. We can create the these vectors using TRUE and FALSE explicitly, or by doing T or F. character: A vector containing strings. A string is a sequence of characters made using double quotes or single quotes, i.e. “Hello” and ‘Goodbye’. An atomic vector only contains elements of the same type. If the function c() is given a mix of elements then it will convert these elements to be all of the same type according to a hierarchy of rules. The only exception to this is for NA values. The object NA is used to indicate missingness, or the lack of a value. The value NA can occur anywhere for all types of vectors. To check the object type we can use the typeof() function. Vectors are among the most common types that are used. All of the different types of vectors we will learn about have special properties and a multitude of features that we can use. We discuss some of their key properties here, but will continue exploring and learning about their features, and introducing more object types throughout the course. 2.1 Examples Double Double vectors are perhaps the most common. These objects are comparable to doubles in C. Both the variables a and b are double vectors. When you type a number R will default to creating a double vector. a &lt;- 17.45 typeof(a) ## [1] &quot;double&quot; b &lt;- 5 typeof(b) ## [1] &quot;double&quot; c &lt;- c(1, 12.05, 123e-4) typeof(c) ## [1] &quot;double&quot; Integer We can also create integer vectors which are specifically made to store integer values. We can do this by following a whole number with the letter L. a &lt;- 5L typeof(a) ## [1] &quot;integer&quot; b &lt;-c(1L, 2L, 3L) typeof(b) ## [1] &quot;integer&quot; Notice that when we define b&lt;-5 and b &lt;- 5L and type b into our console it appears the same. That is, to the user the two definitions look the same. However, in R integers and doubles are stored in the computer differently and have different features. For the most part, the difference between integers and doubles is negligable; however, sometimes it can produce strange errors. Logical Logical values are either TRUE or FALSE and are created by using logical or relational operators. In other words, they are created by using statements that compare variables. There are several ways to do logical statements as we saw in Section 1.4. n &lt;- (10&lt;11) typeof(n) ## [1] &quot;logical&quot; m &lt;- c(10&lt;11, 4&gt;5, 3!=1) typeof(m) ## [1] &quot;logical&quot; We can also assign a value as TRUE or FALSE manually by setting it equal to TRUE or FALSE, or by using T or F. c &lt;- T typeof(c) ## [1] &quot;logical&quot; # Can mix up TRUE/FALSE and T/F d &lt;-c(T, F, TRUE) typeof(d) ## [1] &quot;logical&quot; Character Character values are text. They are often used as data values and labels. # Double quotes first &lt;- &quot;George&quot; typeof(first) ## [1] &quot;character&quot; # Single quotes last &lt;- &#39;Washington&#39; typeof(last) ## [1] &quot;character&quot; full &lt;- c(first, last) typeof(full) ## [1] &quot;character&quot; 2.2 Basic Features R is a vectorized language, meaning most of the procedures, functions, and operations have been optimized to work with vectors. It is typically advantageous to utilize this feature. 2.2.1 Length We have already learned that we can create vectors using the function c(), but this can also be used to make a vector larger. To see how many elements are in a vector we use the length() function v1 = c(1, 5, 6) typeof(v1) ## [1] &quot;double&quot; length(v1) ## [1] 3 v2 = c(-0.41, -1.20, pi) typeof(v2) ## [1] &quot;double&quot; length(v2) ## [1] 3 v = c(v1, v2) typeof(v) ## [1] &quot;double&quot; length(v) ## [1] 6 v ## [1] 1.000000 5.000000 6.000000 -0.410000 -1.200000 3.141593 2.2.2 Vectorized Operations and Recylcing Vectors can be used in arithmetic computations. If the two vectors are of the same length, the computations are performed element-by-element. v1 + v2 ## [1] 0.590000 3.800000 9.141593 v1 * v2 ## [1] -0.41000 -6.00000 18.84956 Single numbers (scalars) will operate on all the vector elements in an expression. 5*v1 ## [1] 5 25 30 v1/3 ## [1] 0.3333333 1.6666667 2.0000000 If you have vectors of different sizes R will recycle values in the smaller vector in order to complete the operation. Sometimes R will give you a warning for this, but often it does not. a &lt;- c(1, 2, 30) b &lt;- c(10, 20) a + b ## Warning in a + b: longer object length is not a multiple of shorter object ## length ## [1] 11 22 40 a &lt; b ## Warning in a &lt; b: longer object length is not a multiple of shorter object ## length ## [1] TRUE TRUE FALSE 2.2.3 Coercion As mentioned above, all elements within a vector must be of the same type. If you attempt to create a vector where some elements are of a different type than the another then R will convert all the elements to be of one type. For example, observe what happens when we try to create a vector with logical and double values. d &lt;- c(TRUE, F, TRUE, 5, 6, 10) d ## [1] 1 0 1 5 6 10 typeof(d) ## [1] &quot;double&quot; In the above example the values for TRUE where converted into 1 and FALSE was converted into a 0. R did the above coercion automatically, but sometimes you will want to convert a vector type explicitly. To do this we use the as.*() functions, where * is replaced by “double”, “integer”, “character”, or “logical”. # Convert to a character vector char_d &lt;- as.character(d) char_d ## [1] &quot;1&quot; &quot;0&quot; &quot;1&quot; &quot;5&quot; &quot;6&quot; &quot;10&quot; typeof(char_d) ## [1] &quot;character&quot; # Convert to an integer vector e &lt;- c(1, 2, 3) typeof(e) ## [1] &quot;double&quot; e ## [1] 1 2 3 e &lt;- as.integer(e) typeof(e) ## [1] &quot;integer&quot; e ## [1] 1 2 3 It is not always possible to convert vector types. Sometimes an element of a vector will fail to convert. If this happens a warning may be given, and the value is often replaced by NA. 2.2.4 Testing We can also test what type of object that we have using the is.*() function, where * is replaced by “logical”, “double”, “integer”, or “character”. These function will return TRUE is * matches the typeof() output, and will return FALSE if otherwise. # Create a double vector a &lt;- c(1, 2, 30) typeof(a) ## [1] &quot;double&quot; is.integer(a) # Returns FALSE ## [1] FALSE is.double(a) # Returns TRUE ## [1] TRUE 2.2.5 Names You can name elements of a vector as well. This will produce a named vector. Instead of referring to an elements location in a vector by its order number, you can refer to the name. We can create names for a vector using three different methods. When creating it. By Assigning a character vector to names() Inline with setNames() To create a named vector using the first technique we use the = symbol where the name is on the left of the equal sign, and the element binded to that name is on the right. All of the atomic vectors can be defined so their elements are named. # Using Technique 1 for creating a named vector. named1 &lt;- c(first = &quot;Abraham&quot;, last = &quot;Lincoln&quot;) named1 ## first last ## &quot;Abraham&quot; &quot;Lincoln&quot; To create a named vector using the second technique we use the names() function. This is the most common technique. # Using Technique 2 for creating a named vector named2 &lt;- c(1, 2, 3) names(named2) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;) named2 ## first second third ## 1 2 3 To create a named vector using the third technique we use the setNames() function. This is the least common technique and is hardly used. # Using Technique 3 for creating a named vector named3 &lt;- c(T, F, T) named3 &lt;- setNames(named3, c(&quot;e1&quot;, &quot;e2&quot;, &quot;e3&quot;)) named3 ## e1 e2 e3 ## TRUE FALSE TRUE To see the list of names for a vector at any point use the names() function. When this function is on the right side of an assignment operator this will produce the names of each element of the vector. # To see the names of a vector and not the elements names(named3) ## [1] &quot;e1&quot; &quot;e2&quot; &quot;e3&quot; If you want to remove the names of a vector you can use two techniques. The first technique is to redefined the vector you with to remove the names of with the unname() function. The second technique uses the names() function and sets the names to be equal to NULL. # Remove names using unname() named2 &lt;- unname(named2) named2 ## [1] 1 2 3 # Remove names using names() and NULL names(named3) &lt;- NULL named3 ## [1] TRUE FALSE TRUE 2.2.6 typeof() and class() The typeof() function returns the storage mode of an object, and the types of values this function will return is limited. The six atomic types of vectors each are based on the six fundamental ways R stores data. Thus when we make a standard vector, we can use the typeof() function to see which type of vector we have. There is also a function called class() which is more common to use, and what we will focus on for the rest of the course. The class() function returns very similar output as typeof(), but it can also return more specific types or forms of objects. For example, perhaps you have a vector with special properties or set up. Then you can assign this specific type of vector with a certain class that reflects these properties, and R will know to differentiate how it handles this object based on its class, instead of its storage mode (returned by typeof()). The major difference between the output of typeof() and class() for atomic vectors is that when we have an integer or double vector the class function returns “numeric” for both. v_int &lt;- c(1L, 2L, 3L) class(v_int) ## [1] &quot;integer&quot; v_dbl &lt;- c(1, 2, 3) class(v_dbl) ## [1] &quot;numeric&quot; 2.2.7 Accessing Elements of a Vector Individual elements of a vector can be obtained using an index in square brackets. An index is the location of an element in a vector. For example, the vector v_dbl&lt;- c(10, 11, 12) has three elements. The first elements index is 1, the second elements index is 2, and so on. A negative index removes that element from the vector. The v_dbl[-1] is the vector v_dbl with the first element removed. The concatenate function can be used to obtain two or more elements of a vector in any desired order. Here v_dbl[c(3,2)] returns the third and second elements of the vector v_dbl. v_dbl &lt;- c(10, 11, 12) # Only get the third element v_dbl[3] ## [1] 12 # Get all elements except the first one v_dbl[-1] ## [1] 11 12 # Get the third and second element v_dbl[c(3,2)] ## [1] 12 11 Summary There are 6 types atomic vectors, but four we will primarily focus on: character, logical, integer, and double. The c() function is used to create atomic vectors, and it combines vectors together. All elements of a vector are of the same type. typeof() and class() functions return what type of vector you have. The length() function tells us how many elements are in a vector. The names() and setNames() function can be used to create a named vector. as.*() can be used to convert the type of vector. is.*() can be used to test what type of vector you have. We can access an element of a atomic vector by using v[num], where v is the vector, and num is the index (or location) of the element we are trying to access. Summary of the vectors that we will be learning about. Additional Resources Chapters 2, 3, 4.1, 4.3, 5.1-5.3, 6 of CRAN Intro-to-R Manual Videos: Variables 1 | Types and Assignments Variables 2 | Nameing Conventions and Best Practices Vectors 1 | Introduction "],["write.html", "Chapter 3 Writing in Bookdown", " Chapter 3 Writing in Bookdown Coming soon: Adding chapters Citations "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
